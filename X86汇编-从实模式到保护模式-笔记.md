# X86汇编-从实模式到保护模式-笔记

## 第2章 处理器、内存和指令

### 内存储器

如图2-4 所示，这是所有个人计算机里都会用到的存储器，我们平时把它叫做内存条。

![1724401156593](assets/1724401156593.png)







如图2-5 所示，处理器发出字长控制信号，以指示本次访问的字长是8、16、32 还是64。如果字长是8，而且给出的地址是0002H，那么，本次访问只会影响到内存的一字节；如果字长是16，给出的地址依然是
0002H，那么实际访问的将是地址0002H 处的一个字，低8 位在0002H中，高8 位在0003H 中。

![1724401177086](assets/1724401177086.png)









### 指令和指令集

处理器的设计者用某些数来指示处理器所进行的操作，这称为**指令（Instruction）**，或者叫机器指令，因为只有处理器才认得它们。

一般来说，**指令**由**操作码**和**操作数**构成，但也有小部分指令仅有操作码，而不含操作数。



如图2-6 所示，停机指令仅包含1 字节的操作码F4，而没有操作数。指令的长度不定，短的指令仅有1 字节，而长的指令则有可能达到15 字节（对于INTEL x86 处理器来说）。

![1724401336165](assets/1724401336165.png)

对处理器来说，指令的**操作码**隐含了如何执行该指令的信息，比如它是做什么的，以及怎么去做。

既然操作码中隐含了这么多的信息，那么，处理器就可以“知道”每条指令的长度。这样，当它执行第一条指令B8 5D 00 的时候，就已经知道，这是一个3 字节指令，下一条指令位于3 个字节之后，即内存地址0003H 处。



对于Intel 处理器来说，如果访问内存中的一个字，那么，它规定高字节位于高地址部分，低字节位于低地址部分，这称为低端字节序（Little Endian）。



因为处理器是自动按顺序取指令并加以执行的，在指令中混杂了非指令的数据会导致处理器不能正常工作。为
此，指令和数据要分开存放，分别位于内存中的不同区域，**存放指令的区域叫代码区，存放数据的区域叫数据区。**



每种处理器在设计的时候，也只能拥有有限的指令，从几十条到几百条不等。一个处理器能够识别的指令的集合，称为该处理器的**指令集**。









### 8086 的通用寄存器

8086是Intel 公司第一款16 位处理器，诞生于1978 年，所以说它很古老。

如图2-7 所示，这8 个寄存器中的前4 个，即AX、BX、CX 和DX，又各自可以拆分成两个8 位的寄存器来使用，总共可以提供8 个8位的寄存器AH、AL、BH、BL、CH、CL、DH 和DL。

![1724401765086](assets/1724401765086.png)







### 程序的重定位难题

处理器是自动化的器件，在给出了起始地址之后，它将从这个地址开始，自动地取出每条指令并加以执行。只要每条指令都正确无误，它就能准确地知道下一条指令的地址。这就意味着，完成某个工作的所有指令，必须集中在一起，处于内存的某个位置，形成一个段，叫做**代码段**。

为了做某件事而编写的指令，它们一起形成了我们平时所说的**程序**。程序总要操作**大量的数据**，这些数据也应该集中在一起，位于内存中的某个地方，形成一个段，叫做**数据段**。

段的划分是逻辑上的，从本质上来说，是如何看待和组织内存中的数据。



段在内存中的位置并不重要，因为处理器是可控的，我们可以让它从内存的任何位置开始取指令并加以执行。这里有一个例子，如图2-8 所示，我们有一大堆数字，现在想把它们加起来求出一个总和。

![1724405710774](assets/1724405710774.png)

这里确实有一个难题。

在前面的例子中，所有在执行时需要访问内存单元的指令，使用的都是真实的内存地址。比如A1 00 01，这条指令的意思是从地址为0100H 的内存单元里取出一个字，并传送到寄存器AX。在这里，0100H是一个真实的内存地址，又称**物理地址**。

整个程序（包括代码段和数据段）在内存中的位置，是由我们自己定的。我们把数据段定在0100H，把代码段定在0120H。

问题是，大多数时候，整个程序（包括代码段和数据段）在内存中的位置并不是我们能够决定的。你所运行的程序，在内存中被加载的位置完全是随机的，哪里有空闲的地方，它就会被加载到哪里，并从那里开始被处理器执行。

在指令中使用了绝对内存地址（物理地址），这样的程序是无法重定位的。为了让你写的程序在卖给别人之后，可以在内存中的任何地方正确执行，就只能在编写程序的时候使用**相对地址或者逻辑地址**了，而不能使用真实的物理地址。当程序加载时，这些相对地址还要根据程序实际被加载的位置重新计算。







### 内存分段机制

采用分段策略之后，一个内存单元的地址实际上就可以用 **“段地址：偏移地址”**来表示，这就是通常所说的**逻辑地址**。比如，在图2-10 中，段内第1 个存储单元的地址为A532H:0000H，第3 个存储单元的地址为A532H:0002H

![1724406660996](assets/1724406660996.png)

**为了在硬件一级提供对“段地址：偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器**

- 分别是代码段寄存器（Code Segment，CS）
- 数据段寄存器（Data Segment，DS）。

对CS 内容的改变将导致处理器从新的代码段开始执行。同样，在开始访问内存中的数据之前，也必须首先设置好DS 寄存器，使之指向数据段。

除此之外，最重要的是，**当处理器访问内存时，它把指令中指定的内存地址看成是段内的偏移地址**，而不是物理地址。



如图2-11 所示，代码段的段地址为1020H，数据段的段地址为`1000H`。在代码段中有一条指令`A1 02 00`，它的功能是将地址`0002H` 处的一个字传送到寄存器AX。在这里，处理器将`0002H` 看成是段内的偏移地址，段地址在`DS` 中，应该在执行这条指令之前就已经用别的指令传送到DS 中了。

![1724406907721](assets/1724406907721.png)









### 8086 的内存分段机制

如图2-12 所示

1. 8086 内部有8 个16 位的通用寄存器.

2. 8086 内部有4 个段寄存器。其中，CS 是代码段寄存器，DS 是数据段寄存器，ES 是附加段（Extra Segment）寄存器, SS 是栈段寄存器

3. IP 是指令指针（Instruction Pointer）寄存器，它只和CS 一起使用，而且只有处理器才能直接改变它的内容。

   ```assembly
   ;当一段代码开始执行时，CS 指向代码段的起始地址，IP 则指向段内偏移。
   ;由CS 和IP 共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。
   ;然后，处理器会自动根据当前指令的长度来改变IP 的值，使它指向下一条指令。
   ```


![1724407064607](assets/1724407064607.png)







8086 的**段寄存器**和**IP 寄存器**都是16 位的。8086 却提供了20根地址线。换句话说，它提供的是20 位的物理地址。

为了解决这个问题，8086 处理器在形成物理地址时，先将段寄存器的内容左移4 位（相当于乘以十六进制的10，或者十进制的16），形成20 位的段地址，然后再同16 位的偏移地址相加，得到20 位的物理地址。

定义段地址并设置处理器的段寄存器，其中最重要的是段地址的选取。通常情况下，段地址的选择取决于内存中哪些区域是空闲的。因为偏移地址总是要求从0000H 开始，8086 处理器的逻辑分段，**起始地址都是16 的倍数**，这称为是按**16 字节对齐的**。







## 第4章 计算机的启动过程

### 计算机的加电和复位

在处理器众多的引脚中，有一个是RESET，用于接受复位信号。每当处理器加电，或者RESET 引脚的电平由低变高时[1] ，处理器都会执行一个硬件初始化，以及一个可选的内部自测试（Build-in Self-Test，BIST），然后将内部所有寄存器的内容初始到一个预置的状态。

对于Intel 8086 来说，复位将使代**码段寄存器（CS）**的内容为`0xFFFF`，其他所有寄存器的内容都为0x0000，包括指令指针寄存器（IP）。







### 基本输入输出系统

Intel 8086 可以访问1MB 的内存空间，地址范围为`0x00000 到0xFFFFF`。出于各方面的考虑，计算机系统的设计者将这1MB 的内存空间从物理上分为几个部分。

8086 有20 根地址线，但并非全都用来访问DRAM （ Dynamic Random Access Memory，DRAM）事实上，这些地址线经过分配，大部分用于访问DRAM，剩余的部分给了只读存储器ROM 和外围的板卡，如图4-2 所示

![1724141447523](assets/1724141447523.png)

因为8086 加电或者复位时，`CS=0xFFFF，IP=0x0000`，所以，它取的第一条指令位于物理地址`0xFFFF0`，正好位于ROM 中，那里固化了开机时需要执行的指令。

处理器取指令执行的自然顺序是从内存的低地址往高低地址推进。

ROM 中位于物理地址0xFFFF0 的地方，通常是一个跳转指令，它通过改变CS 和IP的内容，使处理器从ROM 中的较低地址处开始取指令执行。

```assembly
jmp 0xf000:0xe05b
```

因此，目标位置的物理地址是0xfe05b。一旦执行这条指令，处理器将开始从指定的“段: 偏移”处开始重新取指令执行。

这块ROM 芯片中的内容包括很多部分，主要是进行硬件的诊断、检测和初始化。这块ROM 芯片只针对那些
最基本的、对于使用计算机而言最重要的设备，而它所提供的软件例程，也只包含最基本、最常规的功能。正因为如此，这块芯片又叫基本输入输出系统**（Base Input & Output System，BIOS）ROM**。







### 一切从主引导扇区开始

ROM-BIOS 的容量是有限的，当它完成自己的使命后，最后所要做的，就是从辅助存储设备读取指令数据，然后转到那里开始执行。

硬盘的第一个扇区是0 面0 道1 扇区，或者说是0 头0 柱1 扇区，这个扇区称为主引导扇区。如果计算机的设置是从硬盘启动，那么，ROM-BIOS 将 读 取 硬 盘 主 引 导 扇 区 的 内 容 ， 将 它 加 载 到 内 存 地 址`0x0000:0x7c00 `处（也就是物理地址0x07C00），然后用一个`jmp` 指令跳到那里接着执行：

```assembly
jmp 0x0000:0x7c00
```









## 第5章 编写主引导扇区代码

### 在屏幕上显示文字

为了显示文字，通常需要两种硬件:

- 显示器：显示器的职责是将那些内容以视觉可见的方式呈现在屏幕上。
- 显卡：显卡的职责是为显示器提供内容，并控制显示器的显示模式和状态
  - 显卡控制显示器的最小单位是像素，一个像素对应着屏幕上的一个点。
  - 显卡都有自己的存储器，因为它位于显卡上，故称显示存储器（Video RAM：VRAM），简称显存，要显示的内容都预先写入显存。





如图5-1 所示，显存的第1 个字节对应着屏幕左上角连续的8 个像素；第2 个字节对应着屏幕上后续的8 个像素，后面的以此类推。

![1724139211070](assets/1724139211070.png)

显卡的工作是周期性地从显存中提取这些比特，并把它们按顺序显示在屏幕上。

黑色和白色只需要1 个比特就能表示，但要显示更多的颜色，1 个比特就不够了。现在最流行的，是用24 个比特，即3 个字节，来对应一个像素 。





如图5-2 所示，可以将字符的代码存放到显存里，第1 个代码对应着屏幕左上角第1 个字符，第2 个代码对应着屏幕左上角第2 个字符，后面的以此类推。

这种专门用于显示字符的工作方式称为文本模式。文本模式和图形模式是显卡的两种基本工作模式，可以用指令访问显卡，设置它的显示模式。在不同的工作模式下，显卡对显存内容的解释是不同的。

![1724396380321](assets/1724396380321.png)







计算机系统的设计者们，这些敢想敢干的人，决定把显存映射到处理器可以直接访问的地址空间里，也就是内存空间里。

如图5-3 所示，我们知道，8086 可以访问1MB 内存。其中，`0x00000～9FFFF` 属于常规内存，由内存条提供；`0xF0000～0xFFFFF`由主板上的一个芯片提供，即`ROM-BIOS`。

这样一来，中间还有一个320KB 的空洞，即`0xA0000～0xEFFFF`。传统上，这段地址空间由特定的外围设备来提供，其中就包括显卡。

由于历史的原因，所有在个人计算机上使用的显卡，在加电自检之后都会把自己初始化到80× 25 的文本模式。所以，如图5-3 所示，一直以来，`0xB8000～0xBFFFF` 这段物理地址空间，是留给显卡的，由显卡来提供，用来显示文本。除非显卡出了毛病，否则这段空间总是可以访问的。

![1724139241564](assets/1724139241564.png)







屏幕上的每个字符对应着显存中的两个连续字节，前一个是字符的ASCII 代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）。如图5-4 所示，字符的显示属性（1 字节）分为两部分，低4 位定义的是前景色，高4 位定义的是背景色。

![1724396923318](assets/1724396923318.png)













### 标号和汇编地址

处理器访问内存时，采用的是“段地址：偏移地址”的模式。对于任何一个内存段来说，段地址可以开始于任何16 字节对齐的地方，偏移地址则总是从0x0000 开始递增。



**汇编地 址** 是 在 源 程 序 编 译 期 间 ， **编 译 器** 为 每 条 指 令 确 定 的 汇 编 位 置（Assembly Position），指示该指令相对于程序或者段起始处的距离，以字节计。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。

在编译阶段，每条指令都被计算并赋予了一个汇编地址，就像它们已经被加载到内存中的某个段里一样。实际上，如图5-5 所示，当编译好的程序加载到物理内存后，它在段内的偏移地址和它在编译阶段的汇编地址是相同的。



![1724139268867](assets/1724139268867.png)

正如图5-5 所示，编译后的程序是整体加载到内存中某个段的，交叉箭头用于指示它们之间的映射关系。之所以箭头是交叉的，是因为源程序的编译是从上往下的，而内存地址的增长是从下往上的（从低地址往高地址方向增长）。





在NASM 汇编语言里，每条指令的前面都可以拥有一个标号，以代表和指示该指令的汇编地址。

```assembly
infi: jmp near infi

;标号之后的冒号是可选的。所以下面的写法也是正确的
infi jmp near infi

;标号可以单独占用一行的位置
infi:
	jmp near infi
```





如图5-7 所示，这里显示的是整个`0x0000` 段，其中深色部分为主引导扇区所处的位置。主引导扇区代码是被加载到`0x0000:0x7C00` 处的，而非`0x0000:0x0000`。对于程序的执行来说，这不会有什么问题，因为主引导扇区的内容被加载到内存中并开始执行时，`CS=0x0000`， `IP=0x7C00`.

加载位置的改变不会对处理器执行指令造成任何困扰，但会给数据访问带来麻烦。要知道，当前数据段寄存器`DS `的内容是`0x0000`，因此，`number` 的偏移地址实际上是`0x012E+0x7C00=0x7D2E`。

![1724139291427](assets/1724139291427.png)









## 第6章 相同的功能，不同的代码

### 段地址的初始化

汇编语言源程序的**编译**符合一种假设，即编译后的代码将从某个内存段中，偏移地址为0 的地方开始加载。这样一来，如果有一个标号“label_a”，它在编译时计算的汇编地址是`0x05`，那么，当程序被加载到内存后，它在段内的偏移地址仍然是`0x05`，任何使用这个标号来访问内存的指令都不会产生问题。

但是，如果程序加载时，不是从段内偏移地址为0 的地方开始的，而是`0x7c00`，那么，`label_a` 的**实际偏移地址**就是`0x7c05`。这时，所有访问`label_a` 的指令仍然会访问偏移地址0x05，因为这是在编译时就决定了的。

好 在 Intel 处 理 器 的 分 段 策 略 还 是 很 灵 活 的 ， 逻 辑 地 址`0x0000:0x7c00` 对应的物理地址是`0x07c00`，该地址又是段`0x07C0` 的起始 地 址 。 因 此 ， 这 个 物 理 地 址 其 实 还 对 应 着 另 一 个 逻 辑 地 `0x07c0:0000`，如图6-1 所示。

![1724139431332](assets/1724139431332.png)







### 段之间的批量数据传送

如图6-2 所示，在8086 处理器里，有一个特殊的寄存器，叫做标志寄存器FLAGS。作为一个例子，它的第6 位是ZF（Zero Flag），即零标志。当处理器执行一条算术或者逻辑运算指令后，算术逻辑部件送出的结果除了送到指令中指定位置（目的操作数指定的位置）外，还送到一个或非门。这就是说，如果计算结果为0，这一位被置成1，表示计算结果为零是“真”的；否则清除此位（0）。

![1724139607378](assets/1724139607378.png)









### 数位的显示

如图6-5 所示，数据的传送是按低端字节序的，寄存器的低字节传送到显示缓冲区的低地址部分（字节），寄存器的高字节传送到显示缓冲区的高地址部分（字节）。

![1724139645716](assets/1724139645716.png)









## 第7章 比高斯更快的计算

### 栈和栈段的初始化

栈（Stack）是一种特殊的数据存储结构，数据的存取只能从一端进行。栈也被定义成一个内存段，叫栈段（Stack Segment），由段寄存器SS 指向。

针对栈的操作有两种，分别是将数据推进栈（push）和从栈中弹出数据（pop）。压栈和出栈只能在一端进
行，所以需要用**栈指针寄存器SP （Stack Pointer）**来指示下一个数据应当压入栈内的什么位置，或者数据从哪里出栈。

定义栈需要两个连续的步骤，即初始化段寄存器SS 和栈指针SP 的内容。

![1724139766384](assets/1724139766384.png)





### 本章代码内存布局

到目前为止，我们已经定义了3 个段，图7-2 是当前的内存布局。

![1724139778384](assets/1724139778384.png)





### 第一次push操作

如图7-3 所示，代码段和栈段是同一个段，所以段寄存器`CS `和`SS`的内容都是`0x0000`。而且，栈指针寄存器**SP** 的内容在源程序第42 行被置为`0`。所以，当push 指令第一次执行时(push 指令的操作数是字)，SP 的内容减2，即`0x0000－0x0002＝0xFFFE`，借位被忽略。于是，被压入栈的数据，在内存中的位置实际上是`0x0000:0xFFFE`。

![1724139803234](assets/1724139803234.png)









## 第8章 硬盘和显卡的访问与控制

操作系统也位于硬盘上。操作系统是需要安装到硬盘上的，这个安装过程不但要把操作系统的指令和数据写入硬
盘，通常还要更新主引导扇区的内容，好让这块跳板直接连着操作系统。

操作系统通常肩负着处理器管理、内存分配、程序加载、进程（即已经位于内存中的程序）调度、外围设备（显卡、硬盘、声卡等）的控制和管理等任务。

编译好的程序通常都存放在像硬盘这样的载体上，需要加载到内存之后才能执行。这个过程并不简单，首先要读取硬盘，然后决定把它加载到内存的什么位置。最重要的是，程序通常是分段的，载入内存之后，还要重新计算段地址，这叫做段的重定位。



在本章，我们**把主引导扇区改造成一个程序加载器**，或者说是一个加载程序，它的功能是加载用户程序，并执行该程序（将处理器的控制权交给该程序）。





### 用户程序的结构

处理器的工作模式是将内存分成逻辑上的段，指令的获取和数据的访问一律按“段地址：偏移地址”的方式进行。相对应地，**一个规范的程序，应当包括代码段、数据段、附加段和栈段。**

Intel 处理器要求段在内存中的起始物理地址起码是16 字节对齐的。相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。





作为程序员，每个段的用途，你自己是清楚的。如图8-1 所示，第一个段的名字是“header”，表明它是整个程序的开头部分；第二个段的名字是“code”，表明这是代码段；第三个段的名字是“data”，表明这是数据段

![1724638822158](assets/1724638822158.png)





一旦定义段，那么，后面的内容就都属于该段，除非又出现了另一个段的定义。另外，如图8-2 所示，**有时候，程序并不以段定义语句开始。**在这种情况下，这些内容默认地自成一个段。最为典型的情况是，整个程序中都没有段定义语句。这时，整个程序自成一个段。

![1724638988281](assets/1724638988281.png)







### 用户程序头部

本章的用户程序实际上定义了7 个段，分别是第7行定义的段header、第27 行定义的段code_1、第
163 行定义的段code_2、第173 行定义的段data_1、第194 行定义的段data_2、第201 行定义的段stack 和第208 行定义的段trail。



如图8-5 所示，加载器必须了解一些必要的信息，虽然不是很多，但足以知道如何加载用户程序。

![1724639221280](assets/1724639221280.png)

头部需要在源程序以一个段的形式出现。用户程序头部起码要包含以下信息。

- ① 用户程序的尺寸，即以字节为单位的大小。
- ② 应用程序的入口点，包括段地址和偏移地址。必须在头部给出第一条指令的段地址和偏移地址，这就是所谓的应用程序入口点（Entry Point）。
- ③ 段重定位表。
  - 比较大的程序可能会包含多个代码段和多个数据段。这些段如何使用，是用户程序自己的事，但前提是程序加载到内存后，每个段的地址必须重新确定一下。
  - 段的重定位是加载器的工作，它需要知道每个段在用户程序内的位置，即它们分别位于用户程序内的多少字节处。为此，需要在用户程序头部建立一张段重定位表。







### 加载程序（器）的工作流程

加载器要加载一个用户程序，并使之开始执行，需要决定两件事。

- 第一，看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序；
- 第二，用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少。

图8-7 可用于加载用户程序的空间范围

![1724639569376](assets/1724639569376.png)









用户程序加载地址实际上是保存在标号phy_base 处的一个双字单元里。这是一个32 位的数，在16 位的处理器上，只能用两个寄存器存放。如图8-8 所示，32 位数内存中的存放是按低端序列的，高16位处在phy_base＋0x02 处，可以放在寄存器DX 中；低16 位处在phy_base 处，可以用寄存器AX存放。

![1724639714946](assets/1724639714946.png)



加载器的下一个工作是从硬盘读取用户程序，说白了就是访问其他硬件。







### 外围设备及其接口

外围设备（Peripheral Equipment）。一般来说，我们把这些设备分成两种，

- 一种是输入设备，比如键盘、鼠标、麦克风、摄像头等；
- 另一种是输出设备，比如显示器、打印机、扬声器等。

输入设备和输出设备统称输入输出（Input/Output，I/O）设备。





**I/O 接口**可以是一个电路板，也可能是一块小芯片，这取决于它有多复杂。无论如何，它是一个典型的**变换器**

- 在一边，它按处理器的信号规程工作，负责把处理器的信号转换成外围设备能接受的另一种信号
- 在另一边，它也做同样的工作，把外围设备的信号变换成处理器可以接受的形式。

I/O 接口面临的2个问题

- ① 不可能将所有的I/O 接口直接和处理器相连。
- ② 每个设备的I/O 接口都抢着和处理器说话，不发生冲突都难。

对第1 个问题的解答是采用总线技术。总线可以认为是一排电线，所有的外围设备，包括处理器，都连接到这排电线上。但是，每个连接到这排电线上的器件都必须有拥有电子开关，以使它们随时能够同这排电线连接，或者从这排电线上断开（脱离）。这排公共电线就称为**总线（Bus）**。

对第2 个问题的解答是使用**输入输出控制设备集中器（I/O Controller Hub，ICH）芯片**，该芯片的作用是连接不同的总线，并协调各个I/O 接口对处理器的访问。在个人计算机上，这块芯片就是所谓的南桥。





如图8-9 所示，处理器通过局部总线连接到ICH 内部的处理接口电路。然后，在ICH 内部，又通过总线与各个I/O 接口相连。

![1724640554235](assets/1724640554235.png)

不管是什么设备，都必须通过它自己的**I/O 接口电路**同**ICH** 相连。为了方便，最好是在主板上做一些**插槽**，同时，每个设备的I/O 接口电路都设计成**插卡**。这样，想接上该设备时，就把它的I/O 接口卡插上，不需要时，随时拔下。

每个I/O 接口卡可能连接不止一个设备。比如USB 接口，就有可能连接一大堆东西：键盘、鼠标、U 盘
等。因为同类型的设备较多，也涉及线路复用和仲裁的问题，故它们也有自己的总线体系，称为**通信总线**或者**设备总线**。比如图8-9 所示的USB总线和SATA 总线。







### I/O 端口和端口访问

外围设备和处理器之间的通信是通过相应的I/O 接口进行的。具体地说，处理器是通过**端口（Port）**来和**外围设备**打交道的。**本质上，端口就是一些寄存器**，类似于处理器内部的寄存器。不同之处仅仅在于，**这些叫做端口的寄存器位于I/O 接口电路中。**

**端口**是处理器和外围设备通过I/O 接口交流的窗口，**每一个I/O 接口都可能拥有好几个端口，分别用于不同的目的。**

比如，连接硬盘的PATA/SATA 接口就有几个端口

- **命令端口**（当向该端口写入0x20时，表明是从硬盘读数据；写入0x30 时，表明是向硬盘写数据）
- **状态端口**（处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误）
- **参数端口**（处理器通过这些端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号）
- **数据端口**（通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据）





端口在不同的计算机系统中有着不同的实现方式。

- 在一些计算机系统中，**端口号是映射到内存地址空间的**。

  - 比如，`0x00000～0xE0000` 是真实的物理内存地址，而`0xE0001～0xFFFFF` 是从很多I/O 接口那里映射过来的，当访问这部分地址时，实际上是在访问I/O 接口。

- 而在另一些计算机系统中，**端口是独立编址**的，不和内存发生关系。如图8-10 所示，在这种计算机中，处理器的地址线既连接内存，也连接每一个I/O 接口。但是，处理器还有一个特殊的引脚M/IO#，在这里，“#”表示低电平有效。也就是说，当处理器访问内存时，它会让M/IO#引脚呈高电平，这里，和内存相关的电路就会打开；相反，如果处理器访问I/O 端口，那么M/IO#引脚呈低平，内存电路被禁止。

  ![1724642069552](assets/1724642069552.png)







独立编址的端口，所有端口都是统一编号的，比如`0x0001、0x0002、0x0003、…`。每个I/O 接口电路都分配了若干个端口，比如，I/O 接口A 有3 个端口，端口号分别是0x0021～0x0023；

在Intel 的系统中，只允许65536（十进制数）个端口存在，端口号从0 到65535（0x0000～0xffff）。因为是独立编址，所以，端口的访问不能使用类似于`mov` 这样的指令，取而代之的是`in` 和`out` 指令。

`in` 指令是从端口读，in 指令的目的操作数必须是寄存器AL 或者AX。in 指令的源操作数应当是寄存器DX或者是8位立即数

```assembly
in al,dx
in ax,dx
in ax,0x03
```

`out` 指令，通过端口向外围设备发送数据，正好和`in` 指令相反，目的操作数可以是8 位立即数或者寄存器DX，源操作数必须是寄存器AL 或者AX。

```assembly
out 0x37,al
out dx,ax
out dx,ax
```

`in, out` 指令不影响任何标志位。







### 通过硬盘控制器端口读扇区数据

**硬盘读写的基本单位是扇区。**就是说，要读就至少读一个扇区，要写就至少写一个扇区，不可能仅读写一个扇区中的几个字节。这样一来，就使得主机和硬盘之间的数据交换是成块的，所以硬盘是典型的**块设备**。



从硬盘读写数据，最经典的方式是向硬盘控制器分别发送磁头号、柱面号和扇区号（扇区在某个柱面上的编号），这称为CHS 模式。实际上，在很多时候，我们并不关心扇区的物理位置，所以希望所有的扇区都能统一编址。这就是逻辑扇区，它把硬盘上所有可用的扇区都一一从0 编号，而不管它位于哪个盘面，也不管它属于哪个柱面。

最早的**逻辑扇区编址方法**是LBA28，使用28 个比特来表示逻辑扇区号，从逻辑扇区0x0000000 到0xFFFFFFF，共可以表示228＝268435456 个扇区。每个扇区有512 字节，所以LBA28 可以管理128 GB 的硬盘。业界又共同推出了LBA48，采用48 个比特来表示逻辑扇区号。如此一来，就可以管理131072 TB 的硬盘容量了。



前面说过，个人计算机上的主硬盘控制器被分配了8 个端口，端口号从0x1f0 到0x1f7。

假设现在要**从硬盘上读逻辑扇区**，那么，整个过程如下。

- 第1 步，设置要读取的扇区数量。这个数值要写入0x1f2 端口。

  - 注意，如果写入的值为0，则表示要读取256 个扇区。每读一个扇区，这个数值就减一。

- 第2 步，设置起始LBA 扇区号。

  - 扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。

  - 28 位的扇区号太长，需要将其分成4段，分别写入端口0x1f3、0x1f4、0x1f5 和0x1f6 号端口。

  - 如图8-11所示，0x1f6 端口的低4 位用于存放逻辑扇区号的24～27位，第4 位用于指示硬盘号，0 表示主盘，1 表示从盘。高3 位是“111”，表示LBA 模式。

    ![1724643274677](assets/1724643274677.png)

- 第3 步，向端口0x1f7 写入0x20，请求硬盘读。

- 第4 步，等待读写操作完成。端口0x1f7 既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。

  - 如图8-12 所示，在它内部操作期间，它将0x1f7 端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3 位置“1”，意思是准备好了，请求主机发送或者接收数据

    ![1724643524621](assets/1724643524621.png)

- 第5 步，连续取出数据。0x1f0 是硬盘接口的数据端口，而且还是一个16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。

- 最后，0x1f1 端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态（错误原因）。











### 过程调用

处 理 器 支 持 一 种 叫 过 程 调 用 的 指 令 执 行 机 制 。 过 程（ Procedure ） 又 叫 例 程，子 例 程 （Sub routine），实质是一段普通的代码。

处理器可以用**过程调用指令**转移到这段代码执行，在遇到**过程返回指令**时重新返回到调用处的下一条指令接着执行。

如图8-13 所示，这是过程和过程调用的示意图。

![1724643756518](assets/1724643756518.png)

**要调用过程，需要该过程的地址**。一般来说，过程的第一条指令需要一个标号，以方便引用该过程。

编写过程的好处是只用编写一次，以后只需要“调用”即可。参数传递最简单的办法是通过寄存器。

在调用过程前，程序会用到一些寄存器，在过程返回之后，可能还要继续使用。为了不失连续性，在过程的开头，应当将本过程要用到（内容肯定会被破坏）的寄存器临时压栈，并在返回到调用点之前出栈恢复。





调用过程的指令是“call”。8086 处理器支持四种调用方式。

- 第一种是16 位**相对近调用** 。

  ```assembly
  call near proc_1
  call proc_1
  ```

  - 近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，所以只需要得到偏移地址即可。

- 第二种是16 位**间接绝对近调用** 。

  ```assembly
  call cx
  call [0x3000]
  call [bx+si+0x02]
  ```

  - 这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址。

- 第三种是16 位**直接绝对远调用** 。

  ```assembly
  call 0x2000:0x0030
  ```

  - 这种调用属于段间调用，即调用另一个代码段内的过程，所以称为远调用（far call）。

- 第四种是16 位**间接绝对远调用** 。

  ```assembly
  call far [0x2000]
  call far [bx]
  ```

  - 这也属于段间调用，被调用过程位于另一个代码段内，而且，被调用过程所在的段地址和偏移地址是间接 给出的。

“过程”就是例行公事，可以随时根据需要调用，但过程执行完了呢，还得返回到调用点继续执行下一条指令，这称为过程返回（Procedure Return）。处理器的发明者们设计了返回指令`ret` 和`retf`。

`ret` 和`retf` 经常用做`call` 和`call far` 的配对指令。ret 是近返回指令，当它执行时，处理器只做一件事，那就是从栈中弹出一个字到指令指针寄存器IP 中。





过程调用案例：如图8-14 所示，在call read_hard_disk_0 执行前，栈指针位于箭头①所指示的位置；call 指令执行后，由于压入了IP 的内容，故栈指针移动到箭头②所指示的位置处；进入过程后，出于保护现场的目的，压入了4 个通用寄存器AX、BX、CX、DX，此时，栈指针继续向低地址方向推进到箭头③所指示的位置。

在过程的最后，是恢复现场，连续反序弹出4 个通用寄存器的内容。此时，栈指针又回到刚进入过程内部时的位置，即箭头②处。最后，ret指令执行时，由于处理器自动弹出一个字到IP，故，过程返回后的瞬间，栈指针仍旧回到过程调用前，即箭头①所指示的位置。

![1724644560236](assets/1724644560236.png)

需要说明的是，尽管call 指令通常需要ret/retf 和它配对，遥相呼应，但ret/retf 指令却并不依赖于call 指令。

call 指令在执行过程调用时不影响任何标志位，ret/retf 指令对标志位也没有任何影响。









### 加载用户程序

第一次读硬盘将得到用户程序最开始的512 字节，这512 字节包括最开始的用户程序头部，以及一部分实际的指令和数据。

为了将用户程序全部读入内存，需要知道它的大小，然后再进一步转换成它所用的扇区数。如图8-15 所示，用
户程序最开始的双字，就是整个程序的大小。

![1724644867405](assets/1724644867405.png)

某个扇区里，哪些数据是有用的，哪些是填充的，不是硬盘的责任，是软件的责任。







### 用户程序重定位

用户程序在编写的时候是分段的。因此，加载器下一步的工作是**计算和确定每个段的段地址**。



如图8-16 所示，用户程序定义了6 个段，在编译阶段，编译器为每个段计算了一个汇编地址。

![1724646234835](assets/1724646234835.png)







### 将控制权交给用户程序

现在，用户程序已经在内存中准备就绪，剩下的工作就是把处理器的控制权交给它。交接工作很简单，代码清单8-1 第76 行，加载器通过一个16 位的间接绝对远转移指令，跳转到用户程序入口点。

处理器执行指令

```assembly
jmp far [x004]
```

时，会访问段寄存器DS 所指向的数据段，从偏移地址为0x04 的地方取出两个字，并分别传送到代码段寄存器CS 和指令指针寄存器IP，以替代它们原先的内容。于是，处理器就像被洗脑了一样，自行转移到指定的位置处开始执行。











## 第9章 中断和动态时钟显示

**中断（Interrupt）**就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。





### 外部硬件中断

外部硬件中断，就是从处理器外面来的中断信号。

如图9-1 所示，外部硬件中断是通过两个信号线引入处理器内部的。从很早的时候起，也就是8086 处理器的时代，这两根线的名字就叫NMI和INTR。

![1724653105879](assets/1724653105879.png)



#### 非屏蔽中断

所有的严重事件都必须无条件地加以处理，这种类型的中断是不会被阻断和屏蔽的，称为**非屏蔽中断（Non Maskable Interrupt，NMI）**。



当一个中断发生时，处理器将会通过中断引脚NMI 和INTR 得到通知。每种类型的中断都被统一编号，这称为中断类型号、中断向量或者**中断号**。但是，由于不可屏蔽中断的特殊性——几乎所有触发NMI 的事件对处理器来说都是致命的，甚至是不可纠正的。

也正是这个原因，在实模式下，NMI 被赋予了统一的中断号2，不再进行细分。一旦发生2号中断，处理器和软件系统通常会放弃继续正常工作的“念头”，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。







#### 可屏蔽中断

可屏蔽中断：这类硬件中断有两个特点，

- 第一是数量很多，毕竟有很多外部设备；
- 第二是它们可以被屏蔽，这样处理器就像是没听见、没看见一样，不会对它们进行处理。

可屏蔽中断是通过INTR 引脚进入处理器内部的



**中断控制器**/**可编程中断控制器（Programmable Interrupt Controller，PIC）**

- 一个代理，用来接受外部设备发出的中断信号。
- 对多个中断信号进行仲裁，以决定让它们中的哪一个优先向处理器提出服务请求。

Intel 处理器允许256 个中断，中断号的范围是0～255，8259芯片 负责提供其中的15 个，但中断号并不固定。该
中断控制器芯片有自己的端口号，可以像访问其他外部设备一样用`in 和out` 指令来改变它的状态，包括各引脚的中断号。



如图9-2 所示，8259 的主片引脚0（IR0）接的是系统定时器/计数器芯片；从片的引脚0 （IR0）接的是实时时钟芯片RTC.

在8259 芯片内部，有中断屏蔽寄存器（Interrupt Mask Register，IMR），这是个8 位寄存器，对应着该芯片的8 个中断输入引脚，对应的位是0 还是1，决定了从该引脚来的中断信号是否能够通过8259 送往处理器

![1724653704971](assets/1724653704971.png)

在处理器内部，标志寄存器有一个标志位IF，这就是中断标志（Interrupt Flag）。当IF 为0时，所有从处理器INTR 引脚来的中断信号都被忽略掉；当其为1 时，处理器可以接受和响应中断。

IF 标志位可以通过两条指令`cli` 和`sti` 来改变。这两条指令都没有操作数，`cli（Clear Interrupt flag）`用于清除IF 标志位，`sti（Set Interrupt flag）`用于置位IF 标志。







#### 实模式下的中断向量表

所谓中断处理，归根结底就是处理器要执行一段与该中断有关的程序（指令）。在实模式下，处理器要求将它们的入口点集中存放到内存中从物理地址`0x00000` 开始，到`0x003ff` 结束，共1KB 的空间内，这就是所谓的**中断向量表（Interrupt Vector Table，IVT）**。





如图9-3 所示，每个**中断**在中断向量表中占2 个字，分别是中断处理程序的**偏移地址**和**段地址**。

![1724654003365](assets/1724654003365.png)

当中断发生时，如果从外部硬件到处理器之间的道路都是畅通的，那么，处理器在执行完当前的指令后，会立即着手为硬件服务。它首先会**响应中断**，告诉8259 芯片准备着手处理该中断。接着，它还会要求8259 芯片把**中断号**送过来。

处理器拿着这个中断号，要顺序做以下几件事。

- ① 保护断点的现场。
  - 首先要将标志寄存器FLAGS 压栈，然后清除它的IF 位和TF 位。
  - 接着，再将当前的**代码段寄存器CS** 和**指令指针寄存器IP** 压栈。
- ② 执行中断处理程序。
  - 处理器已经拿到了中断号，它将该号码乘以4，就得到了该中断入口点在中断向量表中的偏移地址。
  - 接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到IP 和CS，自然地，处理器就开始执行中断处理程序了。
  - 注意，由于IF 标志被清除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用sti 指令开放中断。
- ③ 返回到断点接着执行。
  - 所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS 和FLAGS 的原始内容，于是转到主程序接着执行。



中断随时可能发生，中断向量表的建立和初始化工作是由BIOS 在计算机启动时负责完成的。BIOS 为每个中断号填写入口地址，因为它不知道多数中断处理程序的位置，所以，一律将它们指向一个相同的入口地址，在那里，只有一条指令：`iret`。也就是说，当这些中断发生时，只做一件事，那就是立即返回。

当计算机启动后，操作系统和用户程序再根据自己的需要，来修改某些中断的入口地址，使它指向自己的代码。









### 内 部 中 断

和硬件中断不同，内部中断发生在处理器内部，是由执行的指令引起的。比如，当处理器检测到div 或者idiv 指令的除数为零时，或者除法的结果溢出时，将产生中断0（0 号中断），这就是除法错中断。

再比如，当处理器遇到非法指令时，将产生中断6。

内部中断不受标志寄存器IF 位的影响，也不需要中断识别总线周期，它们的中断类型是固定的，可以立即转入相应的处理过程。









### 软 中 断

软中断是由`int` 指令引起的中断处理。这类中断也不需要中断识别总线周期，中断号在指令中给出。int 指令的格式如下：

```assembly
int3
int imm8
into
```

`int3` 是断点中断指令，机器指令码为CC。这条指令在调试程序的时候很有用，当程序运行不正常时，多数时候希望**在某个地方设置一个检查点，也称断点，来查看寄存器、内存单元或者标志寄存器的内容**，这条指令就是为这个目的而设的。

指令都是连续存放的，因此，所谓的**断点，就是某条指令的起始地址。**



`into` 是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF 位是1，那么，将产生4 号中断。否则，这条指令什么也不做。





#### BIOS 中断

最有名的软中断是BIOS 中断，之所以称为BIOS 中断，是因为这些中断功能是在计算机加电之后，BIOS 程序执行期间建立起来的。



BIOS 中断，又称BIOS 功能调用，主要是为了方便地使用最基本的硬件访问功能。不同的硬件使用不同的中断号，比如，使用**键盘服务**时，中断号是`0x16`，即

```assembly
int 0x16
```



BIOS 可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS 中断是由外部设备接口自己建立的。













## 第10章 32 位x86 处理器编程架构

Intel 32 位处理器架构简称IA-32（Intel Architecture，32-bit），是以1978 年的8086 处理器为基础发展起来的。



处理器虽小，功能却异常复杂。要想把32 位处理器的所有功能都解释清楚，不是一件简单的事情。它不单单是地址线和数据线的扩展，实际上还有更多的部分，包括**高速缓存、流水线、浮点处理部件、多处理器（核）管理、多媒体扩展、乱序执行、分支预测、虚拟化、温度和电源管理**等。





### IA-32 架构的基本执行环境

#### 寄存器的扩展

如图10-1 所示，32 位处理器在16 位处理器的基础上，扩展了这8 个通用寄存器的长度，使之达到32位。

![1724655672696](assets/1724655672696.png)

32 位通用寄存器的高16 位是不可独立使用的，但低16 位保持同16位处理器的兼容性。

在本书中，**32 位模式特指32 位保护模式**。在这种模式下，处理器可以使用它全部的32 根地址线，能够访问4GB 内存。





如图10-2 所示，在32 位模式下，为了生成32 位物理地址，处理器需要使用32 位的指令指针寄存器。EIP 寄存器也只由处理器内部使用，程序中是无法直接访问的。对IP 和EIP 的修改通常是用某些指令隐式进行的，这些指令包括`JMP、CALL、RET 和IRET `等等。

![1724655822144](assets/1724655822144.png)

IA-32 架构的处理器是基于**分段模型**的，因此，32 位处理器依然需要以段为单位访问内存，即使它工作在32 位模式下。不过，它也提供了一种变通的方案，即，只分一个段，段的基地址是0x00000000，段的长度（大小）是4GB。在这种情况下，可以视为不分段，即**平坦模型（Flat Mode）**。

每个程序都有属于自己的内存空间。在32 位模式下，处理器要求在加载程序时，先定义该程序所拥有的段，然后允许使用这些段。定义段时，除了基地址（起始地址）外，还附加了段界限、特权级别、类型等属性。**当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问。**

如图10-2 所示，在32 位模式下，传统的段寄存器，如CS、SS、DS、ES，保存的不再是16位段基地址，而是**段选择子或者段选择器**。除了段选择器之外，每个段寄存器还包括一个不可见部分，称为**描述符高速缓存器**，里面有段的基地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。







#### 基本的工作模式

8086 只有一种工作模式，即实模式。

1985 年的80386 处理器是Intel 公司的第一款32 位产品，而且获得了极大成功，是后续所有32 位产品的基础。80386处理器的寄存器是32位的，而且拥有32 根地址线，可以访问2^32，即4GB 的内存。

80386，以及所有后续的32 位处理器，都兼容实模式，可以运行实模式下的8086 程序。而且，**在刚加电时，这些处理器都自动处于实模式下**，此时，它相当于一个非常快速的8086 处理器。**只有在进行一番设置之后，才能运行在保护模式下。**

在保护模式下，所有的32 位处理器都可以访问多达4GB 的内存，它们可以工作在**分段模型**下，每个段的基地址是32 位的，段内偏移量也是32 位的







#### 线性地址

为IA-32 处理器编程，访问内存时，需要在程序中给出段地址和偏移量，因为分段是IA-32 架构的基本特征之一。传统上，**段地址和偏移地址称为逻辑地址，偏移地址叫做有效地址（Effective Address，EA）**

在指令中给出有效地址的方式叫做**寻址方式（Addressing Mode）**。



段的管理是由处理器的段部件负责进行的，段部件将段地址和偏移地址相加，得到访问内存的地址。一般来说，段部件产生的地址就是物理地址。

IA-32 处理器支持多任务。在多任务环境下，任务的创建需要分配内存空间；当任务终止后，还要回收它所占用的内存空间。IA-32 处理器支持分页功能，分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的，一般为4KB，通过使用页，可以简化内存管理。



如图10-3 所示，当页功能开启时，段部件产生的地址就不再是物理地址了，而是**线性地址（Linear Address）**，线性地址还要经页部件转换后，才是物理地址。

![1724658218394](assets/1724658218394.png)

线性地址的概念用来描述任务的地址空间。如图10-3 所示，IA-32处理器上的每个任务都拥有4GB 的虚拟内存空间，这是一段长4GB 的平坦空间，就像一段平直的线段，因此叫**线性地址空间**。相应地，由段部件产生的地址，就对应着线性地址空间上的每一个点，这就是**线性地址**。









### 现代处理器的结构和特点

#### 流水线

**执行一条指令**需要从内存中取指令、译码、访问操作数和结果，并进行移位、加法、减法、乘法以及其他任何需要的操作。

为了提高处理器的执行效率和速度，可以**把一条指令的执行过程分解成若干个细小的步骤，并分配给相应的单元来完成**。各个单元的执行是独立的、并行的。如此一来，各个步骤的执行在时间上就会重叠起来，这种执行指令的方法就是**流水线（Pipe-Line）技术**。

比如，一条指令的执行过程分为取指令、译码和执行三个步骤，而且假定每个步骤都要花1个时钟周期，那么，如图10-4 所示，如果采用顺序执行，则执行三条指令就要花9 个时钟周期，每3 个时钟周期才能得到一条指令的执行结果；如果采用3 级流水线，则执行这三条指令只需5个时钟周期，每隔一个时钟周期就能得到一条指令的执行结果。

![1724658473256](assets/1724658473256.png)







#### 高速缓存

影响处理器速度的另一个因素是**存储器**。从处理器内部向外看，它们分别是寄存器、内存和硬盘。

因为需要等待内存和硬盘这样的慢速设备，处理器便无法全速运行。为了缓解这一矛盾，**高速缓存（Cache）技术**应运而生。**高速缓存是处理器与内存（DRAM）之间的一个静态存储器**，容量较小，但速度可以与处理器匹配。

高速缓存的用处源于程序在运行时所具有的局部性规律。

利用**程序运行时的局部性原理**，可以把处理器正在访问和即将访问的指令和数据块从内存调入高速缓存中。于是，每当处理器要访问内存时，首先检索高速缓存。

- 如果要访问的内容已经在高速缓存中，那么，很好，可以用极快的速度直接从高速缓存中取得，这称为**命中（Hit）**；
- 否则，称为**不中（miss**）。在不中的情况下，处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中去取那个内容。高速缓存的装载是以块为单位的，包括那个所需数据的邻近内容。
  - 为此，需要额外的时间来等待块从内存载入高速缓存，在该过程中所损失的时间称为**不中惩罚（miss penalty）**。







#### 乱序执行

为了实现流水线技术，需要将指令拆分成更小的可独立执行部分，即拆分成**微操作（microoperations）**，简写为**μops**。

一旦将指令拆分成微操作，处理器就可以在必要的时候**乱序执行（Out-Of-Order Execution）**程序。







#### 寄存器重命名

IA-32 架构的处理器只有8 个32 位通用寄存器，但通常都会被我们全部派上用场。不过，在处理器内部，却有大量的**临时寄存器**可用，**处理器可以重命名这些寄存器以代表一个逻辑寄存器**，比如EAX。

寄存器重命名以一种完全自动和非常简单的方式工作。每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器。







#### 分支目标预测

流水线并不是百分之百完美的解决方案。实际上，有很多潜在的因素会使得流水线不能达到最佳的效率。一个典型的情况是，如果遇到一条转移指令，则后面那些已经进入流水线的指令就都无效了。换句话说，我们必须清空（Flush）流水线，从要转移到的目标位置处重新取指令放入流水线。

在现代处理器中，流水线操作分为很多步骤，包括取指令、译码、寄存器分配和重命名、微操作排序、执行和引退。

流水线的最大问题是代码中经常存在分支。随着复杂架构下的流水线变得越来越长，程序分支带来的问题开始变得很大。为了解决这个问题，在1996 年的Pentium Pro 处理器上，引入了**分支预测技术（Branch Prediction）。分支预测的核心问题是，转移是发生还是不会发生**。

从统计学的角度来看，有些事情一旦出现，下一次还会出现的概率较大。

在处理器内部，有一个小容量的高速缓存器，叫**分支目标缓存器（Branch Target Buffer，BTB）**。当处理器执行了一条分支语句后，它会在BTB 中记录当前指令的地址、分支目标的地址，以及本次分支预测的结果。下一次，在那条转移指令实际执行前，处理器会查找BTB，看有没有最近的转移记录。如果能找到对应的条目，则推测执行和上一次相同的分支，把该分支的指令送入流水线。当该指令实际执行时，如果预测是失败的，那么，清空流水线，同时刷新BTB 中的记录。这个代价较大。







### 32 位模式的指令系统

#### 32 位处理器的寻址方式

如图10-5 所示，这是16 位处理器的内存寻址方式示意图。从图中可以看出，允许使用基址寄存器BX 或者BP，同变址寄存器SI 或者DI 结合，再加上8 位或者16 位偏移量来寻址内存操作数。

![1724659220713](assets/1724659220713.png)



16 位处理器的寻址方式本来就很复杂，当32 位处理器出现后，寄存器和偏移地址的宽度都扩展了，相应地，要继续扩展原有的寻址方式。但是，原有的16 位方案已经成型，再进行修补是非常困难的。一个可行的解决方案是，**让16 位指令和32 位指令共用相同的指令码，但通过不同的指令前缀，结合处理器当前的运行状态来决定该指令的寻址方式。**





32 位处理器兼容16 位处理器的工作模式，可以运行传统的16 位代码。

在32 位模式下，默认使用32 位宽度的寄存器。如果指令中包含了内存地址操作数，那么，它必然默认地是一个32 位的有效地址。通过有效地址，可以间接取得32 位的实际操作数。如图10-6 所示

![1724659369230](assets/1724659369230.png)







#### 操作数大小的指令前缀

Intel 处理器的指令系统比较复杂，这种复杂性来源于两个方面，

- 一是指令的数量较多，
- 二是寻址方式也很多。





为了组成这些众多的指令，必须有一套同样复杂的**指令格式**。如图10-7 所示

![1724659491767](assets/1724659491767.png)

- 每一条处理器指令都可以拥有**前缀**，

  - 比如重复前缀（REP/REPE/ REPNE）、段超越前缀（如ES：）、总线封锁前缀（LOCK）等。

- 前缀（如果有的话）的后面是**操作码**部分

  - 指示执行什么样的操作，比如传送、加法、减法、乘法、除法、移位等。

- 操作码之后是**操作数类型和寻址方式**部分。

  - 这部分是可选的，简单的指令不包含这一部分，稍微复杂一点的指令包含。

- 指令的最后是**立即数和偏移量**。

  - 如果指令中使用了立即数，那么立即数就在这一部分给出；如果指令使用了带偏移量的寻址方式，如：

    ```assembly
    mov cx,[0x2000]
    mov ecx,[eax+ebx*8+0x02]
    ```

    那么，偏移量`0x2000 和0x02` 也在这部分出现。





上述的**指令编码格式**发源于16 位处理器时代，并在32 位处理器出现之后做了修改，主要是扩展了数据的宽度，其他都保持不变。

32 位处理器使用相同的**编码格式**，但是，寻址方式和寄存器的定义却是另起炉灶的，完全不同于16 位指令。

如图10-8（b）所示，在32 位处理器上，位7 和位6 的值是01，表示使用了基址寻址方式，而且带有8
位偏移量；位5～位3 的值是010，指示目的操作数为寄存器EDX；位2～位0 的值是000，表示寻址方式为EAX+8 位偏移量。在该字节之后，是1字节的偏移量0x02。因此，同样的机器指令码，却对应着不同的32 位指令：

```assembly
mov edx,[eax+0x02]
```

![1724659975199](assets/1724659975199.png)

相同的机器指令，在16 位模式下和32 位模式下的解释和执行效果是不同的。但是，别忘了，32 位处理器可以执行16 位的程序，包括实模式和16 位保护模式。为此，在16 位模式下，处理器把所有指令都看成是16 位的。相反地，如果处理器运行在32 位模式下，那么，处理器认为指令的操作数都是32 位的。



**指令前缀0x66 具有反转当前默认操作数大小的作用。**

在编写程序的时候，就应当考虑到指令的运行环境。为了指明程序的默认运行环境，编译器提供了伪指令bits，用于指明其后的指令应该被编译成16 位的，还是32 位的。







#### 一般指令的扩展

由于32 位的处理器都拥有32 位的寄存器和算术逻辑部件，而且同内存芯片之间的数据通路至少是32 位的，因此，所有以寄存器或者内存单元为操作数的指令都被扩充，以适应32 位的算术逻辑操作。而且，这些扩展的操作即使是在16 位模式下（实模式和16 位保护模式）也是可用的。

















## 第11章 进入保护模式

一般来说，操作系统负责整个计算机软、硬件的管理，它做任何事情都是可以的。但是，**用户程序却应当有所限制，只允许它访问属于自己的数据，即使是转移，也只允许在自己的各个代码段之间进行。**

问题在于，在实模式下，用户程序对内存的访问非常自由，没有任何限制，随随便便就可以修改任何一个内存单元。

在多用户、多任务时代，内存中会有多个用户（应用）程序在同时运行。为了使它们彼此隔离，防止因某个程序的编写错误或者崩溃而影响到操作系统和其他用户程序，使用**保护模式**是非常有必要的。







### 全局描述符表

在保护模式下，对内存的访问仍然使用段地址和偏移地址，**但是，在每个段能够访问之前，必须先进行登记。**

和一个段有关的信息需要8 个字节来描述，所以称为**段描述符（Segment Descriptor）**，每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个**描述符表**。

**全局描述符表（Global Descriptor Table，GDT）**，所谓全局，意味着该表是为整个软硬件系统服务的。**在进入保护模式前，必须要定义全局描述符表。**



如图11-1 所示，为了跟踪全局描述符表，处理器内部有一个48 位的寄存器，称为**全局描述符表寄存器(GDTR)**。该寄存器分为两部分，分别是32 位的线性地址和16 位的边界。

![1724660777933](assets/1724660777933.png)





理论上，全局描述符表可以位于内存中的任何地方。但是，如图11-2 所示，由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，必须在进入保护模式之前定义GDT。但是，由于在实模式下只能访问1MB 的内存，故GDT 通常都定义在1MB 以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义GDT。

![1724660882114](assets/1724660882114.png)









### 存储器的段描述符

如图11-3 所示，在实模式下，主引导程序的加载位置是0x0000:0x7c00，也就是物理地址0x07c00。因为现在的地址是32 位的，所以它现在对应着物理地址0x00007c00。主引导扇区程序共512（0x200）字节，所以，我们决定把GDT 设在主引导程序之后，也就是物理地址0x00007e00 处。因为GDT 最大可以为64KB，所以，理论上，它的尺寸可以扩展到物理地址0x00017dff 处。

![1724723657651](assets/1724723657651.png)





在保护模式下，你不能说访问哪个段就访问哪个段，在访问之前，必须先在GDT 内定义要访问的内存段。

**描述符**不是由用户程序自己建立的，而是在加载时，由操作系统根据你的程序结构而建立的，而用户程
序通常是无法建立和修改GDT 的，也就只能老老实实地在自己的地盘上工作。

如图11-4 所示，每个描述符在GDT 中占8 字节。

![1724723788717](assets/1724723788717.png)

段基地址可以是0～4GB 范围内的任意地址，不过，还是建议应当选取那些16 字节对齐的地址。尽管对于Intel 处理器来说，允许不对齐的地址，但是，对齐能够使程序在访问代码和数据时的性能最大化。

- G 位是粒度（Granularity）位，用于解释段界限的含义。当G 位是“0”时，段界限以字节为单位。相反，如果该位是“1”，那么，段界限是以4KB 为单位的。
- S 位用于指定描述符的类型（Descriptor Type）。当该位是“0”时，表示是一个系统段；为“1”时，表示是一个代码段或者数据段
- DPL 表示描述符的特权级（Descriptor Privilege Level，DPL）。这两位用于指定段的特权级。共有4 种处理器支持的特权级别，分别是0、1、2、3，其中0 是最高特权级别，3 是最低特权级别。
  - 不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由0 特权级的程序来执行，为的就是安全。
  - 描述符的特权级用于指定要访问该段所必须具有的最低特权级。如果这里的数值是2，那么，只有特权级别为0、1 和2 的程序才能访问该段，而特权级为3 的程序访问该段时，处理器会予以阻止。
- P 是段存在位（Segment Present）。P 位用于指示描述符所对应的段是否存在。
  - 一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P 位清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），这时，同样要把段描述符的P 位清零。当再次轮到它执行时，再装入内存，然后将P位置1。
  - P 位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果P 位是“0”，处理器就会产生一个异常中断。通常，该中断处理过程是由操作系统提供的，该处理过程的任务是负责将该段从硬盘换回内存，并将P 位置1。
- D/B 位是“默认的操作数大小”（Default Operation Size）或者“默认的栈指针大小”（Default Stack Pointer Size），又或者“上部边界”（Upper Bound）标志。
- L 位是64 位代码段标志（64-bit Code Segment），保留此位给64位处理器使用。
- TYPE 字段共4 位，用于指示描述符的子类型，或者说是类别。
- AVL 是软件可以使用的位（Available），通常由操作系统来用，处理器并不使用它。









### 安装存储器的段描述符并加载GDTR

第24、25 行，接着安装代码段描述符，该描述符的低32 位是0x7c0001ff，高32 位是0x00409800。结合图11-4 可以分析出，该段的基本情况为：

![1724724640754](assets/1724724640754.png)





第28、29 行，用于安装一个数据段的描述符。对照图11-4，很明显，这个段具有以下性质：

![1724724685740](assets/1724724685740.png)





第32、33 行，用于安装栈段的描述符。对照图11-4，该段的性质如下：

![1724724740816](assets/1724724740816.png)









### 关于第21 条地址线A20 的问题

处理器的第21 根地址线，编号A20。“A”是Address 的首字符，就是地址，A0 是第一根地址线，A31 是第32 根地址线，所以，A20 就是第21根地址线。



如图11-6 所示，IBM 公司使用一个与门来控制第21 根地址线A20，并把这个与门的控制阀门放在键盘控制器内，端口号是0x60。向该端口写入数据时，如果第1 位是“1”，那么，键盘控制器通向与门的输出就为“1”，与门的输出就取决于处理器A20 是“0”还是“1”。

![1724724863647](assets/1724724863647.png)





如图11-7 所示，输入输出控制器集中芯片ICH 的处理器接口部分，有一个用于兼容老式设备的端口0x92，第7～2 位保留未用，第0 位叫做INIT_NOW，意思是“现在初始化”，用于初始化处理器，当它从0 过渡到1 时，ICH 芯片会使处理器INIT#引脚的电平变低（有效），并保持至少16 个PCI 时钟周期。通俗地说，向这个端口写1，将会使处理器复位，导致计算机重新启动

![1724724925307](assets/1724724925307.png)

端 口 0x92 的 位 1 用 于 控 制 A20 ， 叫 做 替 代 的 A20 门 控 制 （Alternate A20 Gate ， ALT_A20_GATE），它和来自键盘控制器的A20控制线一起，通过或门连接到处理器的A20M#引脚。

**端口0x92 是可读写的，第40～42 行，先从该端口读出原数据，接着，将第2 位（位1）置“1”，然后再写入该端口，这样就打开了A20。**









### 保护模式下的内存访问

实模式和保护模式，控制这两种模式切换的开关原是在一个叫CR0 的寄存器。CR0 是处理器内部的控制寄存器（Control Register，CR）。

CR0 是32 位的寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位。如图11-8 所示，它的第1 位（位0）是保护模式允许位（Protection Enable，PE），是开启保护模式大门的门把手，如果把该位置“1”，则处理器进入保护模式，按保护模式的规则开始运行。

![1724725250310](assets/1724725250310.png)



保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用，而且，必须要知道的是，在保护模式下，BIOS 中断都不能再用，因为它们是实模式下的代码。**在重新设置保护模式下的中断环境之前，必须关中断**，这就是第44 行的用意。





如图11-9 所示，32 位处理器的这6 个段寄存器又分为两部分，前16位和8086 相同，在实模式下，它们用于按传统的方式寻址1MB 内存，使用方法也没有变化，所以使得8086 的程序可以继续在32 位处理器上运行。同时，每个段寄存器还包括一个不可见的部分，称为**描述符高速缓存器**，用来存放段的线性基地址、段界限和段属性。

![1724725398867](assets/1724725398867.png)





在保护模式下，尽管访问内存时也需要指定一个段，但传送到**段选择器**的内容不是逻辑段地址，而是段描述符在描述符表中的索引号。

如图11-10 所示，在保护模式下访问一个段时，传送到段选择器的是**段选择子**。它由三部分组成，第一部分是**描述符的索引号**，用来在描述符表中选择一个段描述符。**TI** 是描述符表指示器（Table Indicator），TI＝0 时，表示描述符在GDT 中；TI＝1 时，描述符在LDT 中。。**RPL** 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。每个程序都有特权级别

![1724725541306](assets/1724725541306.png)







如图11-11 所示，当处理器在执行任何改变段选择器的指令时（比如pop、mov、jmp far、call far、iret、retf），就将指令中提供的索引号乘以8 作为偏移地址，同GDTR 中提供的线性基地址相加，以访问GDT。如果没有发现什么问题（比如超出了GDT 的界限），就自动将找到的描述符加载到不可见的描述符高速缓存部分。

此后，每当有访问内存的指令时，就不再访问GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。

![1724725631015](assets/1724725631015.png)





如图11-12所示，执行这条指令时，处理器用**DS 描述符高速缓存**中的线性基地址加上指令中给出的偏移量0x00，形成32 位物理地址0x000b8000，并将字符“P”的ASCII 码写入该处。

![1724725749194](assets/1724725749194.png)





如图11-13 所示，在32 位保护模式下，处理器使用的指令指针寄存器是EIP。假设已经从描述符表中选择了一个段描述符，**CS 描述符高速缓存器**已经装载了正确的32 位线性基地址，那么，当处理器取指令时，会自动用描述符高速缓存器中的32 位线性基地址加上指令指针寄存器EIP 中的32 位偏移量，形成32 位物理地址，从内存中取得执令并加以执行。同时，EIP 的内容自动增加以指向下一条指令。当前指令执行完毕之后，处理器接着按上述方式取下一条指令加以执行。

![1724725824332](assets/1724725824332.png)









### 清空流水线并串行化处理器

这里有两个亟待解决的问题。

- 第一，正如上一节所述，即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，仅低20 位有效，高12 位是全零。当处理器进入保护模式后，这些内容依然残留着，但不影响使用，程序可以继续执行。但是，这些残留的内容在保护模式下是无效的，迟早会在执行某些指令的时候出问题。因此，比较安全的做法是尽快刷新CS、SS、DS、ES、FS 和GS 的内容，包括它们的段选择器和描述符高速缓存器。
- 第二，在进入保护模式前，有很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按16 位操作数和16 位地址长度进行译码的，即使是那些用bits 32 编译的指令。进入保护模式后，受CS 段描述符高速缓存器中实模式残留内容的影响，处理器进入16 位保护模式工作。如果保护模式下的代码是16 位的，影响可能不大，但如果是用bits 32 编译的，那么，由于对对操作数和默认地址大小的解释不同，指令的执行结果可能会不正确，所以必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。

这里有一个两全其美的方案，那就是使用**远转移指令jmp或者远过程调用指令call**。处理器最怕转移指令，遇到这种指令，一般会**清空流水线，并串行化执行**；另一方面，远转移会重新加载段选择器CS，并刷新描述符高速缓存器中的内容。

一个建议的方法是在设置了控制寄存器CR0 的PE 位之后，立即用jmp 或者call 转移到当前指令流的下一条指令上。



注意，在保护模式下，不允许使用mov 指令改变段寄存器CS 的内容，比如：`mov cs,ax`

企图这样做将导致处理器产生一个无效操作码的异常中断







### 保护模式下的栈

第77～79 行用于初始化保护模式下的栈。栈段描述符是GDT 中的第4 个（3 号）描述符，栈的32 位线性基地址是0x00000000，段界限为0x07a00，粒度为字节，属于可读可写、向下扩展的数据段。



在32 位代码中，是用ESP 作为栈指针的。因此，这里的段界限，用来和段粒度一起，决定ESP 寄存器所能具有的最小值。即，栈操作时，必须符合条件：

```assembly
ESP > 段界限X粒度值
```





你可能觉得当前的栈段很完美。但不得不说，这是一个非常糟糕的栈定义。结合本章的程序，很明显，我们的本意是要定义一个只有512字节的栈空间，从物理地址0x00007A00 开始，到物理地址0x00007C00结束，如图11-14 所示。

![1724726354260](assets/1724726354260.png)











## 第12章 存储器的保护

处理器引入保护模式的目的是提供保护功能，其中很重要的一个方面就是存储器保护。存储器的保护功能可以禁止程序的非法内存访问，比如，向代码段写入数据、访问段界限之外的内存位置等。

凡事都有两面。利用存储器的保护功能，也可以实现一些有价值的功能，比如虚拟内存管理。当处理器访问一个实际上不存在的段时，会引发异常中断。操作系统可以利用这一点，通过接管异常处理过程，并用硬盘来进行段的换入和换出，从而实现在较小的内存空间运行尽可能大、尽可能多的程序。







### 进入32 位保护模式

#### 话说mov ds,ax 和mov ds,eax

**段寄存器（选择器）的值**只能用**内存单元或者通用寄存器**来传送，一般的指令格式为

```assembly
mov sreg,r/m16
```

在16 位模式下，默认的操作数大小是字（2 字节），在32 位模式下，默认的操作数大小是双字（4 字节）。

代码清单12-1 第7、8 行，用于通过寄存器EAX 来初始化栈段寄存器SS。





#### 创建GDT 并安装段描述符

如图12-1，本章程序中各个部分在内存中的分布

![1724921710496](assets/1724921710496.png)



准备进入保护模式。

首先是创建GDT，并安装刚进入保护模式时就要使用的描述符。

- 第21、22 行，安装空描述符。该描述符的槽位号是0，处理器不允许访问这个描述符，任何时候，使用索引字段为0 的选择子来访问该描述符，都会被处理器阻止，并引发异常中断。
- 第25、26 行，安装保护模式下的数据段描述符。参考前面的段描述符格式，可以看出，该段的线性基地址位于整个内存的最低端，为0x00000000；属于32 位的段，段界限是0xFFFFF。但是要注意，段的粒度是以4KB 为单位的。
- 第29、30 行，安装保护模式下的代码段描述符。该段是32 位的代码，线性基地址为0x00007C00；段界限为0x001FF，粒度为字节。
- 第33、34 行，安装保护模式下的数据段描述符。该段是32 位的数据段，线性基地址为0x00007C00；段界限为0x001FF，粒度为字节。
- 第36、37 行，安装保护模式下的栈段描述符。该段的线性基地址是0x00007C00，段界限为0xFFFFE，粒度为4KB。
- 第40 行，设置GDT 的界限值为39，因为这里共有5 个描述符，总大小为40 字节，界限值为39。









### 修改段寄存器时的保护

随着程序的执行，经常要对段寄存器进行修改。此时，处理器在变更段寄存器以及隐藏的描述符高速缓存器的内容时，要检查其代入值的合法性。

代码清单12-1 第55 行，这是一条直接远转移指令：

```assembly
jmp dword 0x0010:flush
```

这条指令会隐式地修改段寄存器CS。



指令涉及段寄存器的修改，处理器把指令中给出的选择子传送到段寄存器的选择器部分。但是，处理器的固件在完成传送之前，要确认选择子是正确的，并且该选择子选择的描述符也是正确的。

- 如图12-2 所示，GDT的基地址和界限，都在寄存器GDTR 中。处理器从GDT 中取某个描述符时，就要求描述符的8 个字节都在GDT 边界之内，也就是索引号×8＋7 小于等于边界。

  ![1724922013833](assets/1724922013833.png)

- 如果检查到指定的段描述符，其位置超过表的边界时，处理器中止处理，产生异常中断13，同时段寄存器中的原值不变。

- 通过了上述检查，并从表中取得描述符后，紧接着还要对描述符的类别进行确认。

  - 举个例子来说，若描述符的类别是只执行的代码段（表11-1），则不允许加载到除CS 之外的其他段寄存器中。

- 然后，检查描述符的类别是否和段寄存器的用途匹配。

- 最后，除了按表12-1 进行段的类别检查外，还要检查描述符中的P位。

  - 如果P＝0，表明虽然描述符已被定义，但该段实际上并不存在于物理内存中。此时，处理器中止处理，引发异常中断11。
  - 如果P＝1，则处理器将描述符加载到段寄存器的描述符高速缓存器，同时置A 位。

- 一旦上述规则全部验证通过，处理器就将选择子加载到段寄存器的选择器。









### 地址变换时的保护

#### 代码段执行时的保护







#### 栈操作时的保护







#### 数据访问时的保护











### 使用别名访问代码段对字符排序






## 第13章 程序的动态加载和执行









## 第14章 任务和特权级保护











## 第15章 任务切换











## 第16章 分页机制和动态页面分配















## 第17章 中断和异常的处理与抢占式多任务

