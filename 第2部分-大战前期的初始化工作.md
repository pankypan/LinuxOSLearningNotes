# 第二部分 大战前期的初始化工作

## 11.整个操作系统就 20 几行代码

### 11.0 main整体

我们的程序终于跳到第一个由 c 语言写的，也是操作系统的全部代码骨架的地方，就是 main.c 文件里的 main 方法。

`init\main.c`

```c
void main(void) {
    ROOT_DEV = ORIG_ROOT_DEV;
    drive_info = DRIVE_INFO;
    memory_end = (1<<20) + (EXT_MEM_K<<10);
    memory_end &= 0xfffff000;
    if (memory_end > 16*1024*1024)
        memory_end = 16*1024*1024;
    if (memory_end > 12*1024*1024) 
        buffer_memory_end = 4*1024*1024;
    else if (memory_end > 6*1024*1024)
        buffer_memory_end = 2*1024*1024;
    else
        buffer_memory_end = 1*1024*1024;
    main_memory_start = buffer_memory_end;

    mem_init(main_memory_start,memory_end);
    trap_init();
    blk_dev_init();
    chr_dev_init();
    tty_init();
    time_init();
    sched_init();
    buffer_init(buffer_memory_end);
    hd_init();
    floppy_init();

    sti();
    move_to_user_mode();
    if (!fork()) {
        init();
    }

    for(;;) pause();
}
```

但这的确是操作系统启动流程的全部秘密了，我用空格将这个代码分成了几个部分。







### 11.1 Part1-参数取值和计算

第一部分是一些参数的取值和计算。

```c
void main(void) {
    ROOT_DEV = ORIG_ROOT_DEV;
    drive_info = DRIVE_INFO;
    memory_end = (1<<20) + (EXT_MEM_K<<10);
    memory_end &= 0xfffff000;
    if (memory_end > 16*1024*1024)
        memory_end = 16*1024*1024;
    if (memory_end > 12*1024*1024) 
        buffer_memory_end = 4*1024*1024;
    else if (memory_end > 6*1024*1024)
        buffer_memory_end = 2*1024*1024;
    else
        buffer_memory_end = 1*1024*1024;
    main_memory_start = buffer_memory_end;
    ...
}
```

包括**根设备 `ROOT_DEV`**，之前在汇编语言中获取的各个设备的**参数信息 `drive_info`**，以及通过计算得到的**内存边界**

```c
main_memory_start
main_memory_end
buffer_memory_start
buffer_memory_end
```



从哪获得之前的设备参数信息呢？如果你前面看了，那一定还记得这个表，都是由 setup.s 这个汇编程序调用 BIOS 中断获取的各个设备的信息，并保存在约定好的内存地址 0x90000 处，现在这不就来取了么

| 内存地址 | 长度(字节) | 名称         |
| -------- | ---------- | ------------ |
| 0x90000  | 2          | 光标位置     |
| 0x90002  | 2          | 扩展内存数   |
| 0x90004  | 2          | 显示页面     |
| 0x90006  | 1          | 显示模式     |
| 0x90007  | 1          | 字符列数     |
| 0x90008  | 2          | 未知         |
| 0x9000A  | 1          | 显示内存     |
| 0x9000B  | 1          | 显示状态     |
| 0x9000C  | 2          | 显卡特性参数 |
| 0x9000E  | 1          | 屏幕行数     |
| 0x9000F  | 1          | 屏幕列数     |
| 0x90080  | 16         | 硬盘1参数表  |
| 0x90090  | 16         | 硬盘2参数表  |
| 0x901FC  | 2          | 根设备号     |









### 11.2 Part2-各类初始化

第二部分是各种初始化 **init** 操作。

```c
void main(void) {
    ...
    mem_init(main_memory_start,memory_end);
    trap_init();
    blk_dev_init();
    chr_dev_init();
    tty_init();
    time_init();
    sched_init();
    buffer_init(buffer_memory_end);
    hd_init();
    floppy_init();
    ...
}
```

包括**内存初始化 `mem_init`**，**中断初始化 `trap_init`**、**进程调度初始化 `sched_init`** 等等。







### 11.3 Part3-切换到用户态模式&新进程创建与初始化

第三部分是**切换到用户态模式**，并在一个新的进程中做一个最终的初始化 init。

```c
void main(void) {
    ...
    sti();
    move_to_user_mode();
    if (!fork()) {
        init();
    }
    ...
}
```

这个 init 函数里会创建出一个进程，设置终端的标准 IO，并且再创建出一个执行 shell 程序的进程用来接受用户的命令，到这里其实就出现了我们熟悉的画面（下面是 bochs 启动 Linux 0.11 后的画面）。

![图片](assets/640-1705459697590.png)







### 1.4 Part4-操作系统standby

第四部分是个**死循环**，如果没有任何任务可以运行，操作系统会一直陷入这个死循环无法自拔。

```c
void main(void) {
    ...
    for(;;) pause();
}
```









### 1.5 当前内存状态

这里再放上目前的内存布局图。

![图片](assets/640-1705460184601-rs.png)

这个图大家一定要牢记在心，**操作系统**说白了**就是在内存中放置各种的数据结构，来实现“管理”的功能。**



所以之后我们的学习过程，主心骨其实就是看看，操作系统在经过一番折腾后，又在内存中建立了什么数据结构，而这些数据结构后面又是如何用到的。

比如**进程管理**，就是在内存中建立好多复杂的**数据结构用来记录进程的信息**，再配合上**进程调度的小算法**，完成了进程这个强大的功能。









## 12.管理内存前先划分出三个边界值

### 12.1 内存边界计算

`init\main.c`

```c
void main(void) {
    ...
    memory_end = (1<<20) + (EXT_MEM_K<<10);
    memory_end &= 0xfffff000;
    if (memory_end > 16*1024*1024)
        memory_end = 16*1024*1024;
    if (memory_end > 12*1024*1024) 
        buffer_memory_end = 4*1024*1024;
    else if (memory_end > 6*1024*1024)
        buffer_memory_end = 2*1024*1024;
    else
        buffer_memory_end = 1*1024*1024;
    main_memory_start = buffer_memory_end;
    ...
}
```

其实就是计算出了两个变量，并且**针对不同的内存大小，设置不同的边界值**

```c
main_memory_start
memory_end
```



举个栗子：

假设总内存一共就 **8M** 大小，**memory_end** 就是 `8 * 1024 * 1024`， **buffer_memory_end** 就为 `2 * 1024 * 1024`，那么**main_memory_start** 也为 `2 * 1024 * 1024`



那这些值有什么用呢？一张图就给你说明白了。

![640](assets/640-1705460941591-rs.png)

其实就是定了三个箭头所指向的地址的三个边界变量，具体主内存区是如何管理和分配的，要看下面代码的功劳。

```c
void main(void) {
    ...
    mem_init(main_memory_start, memory_end);
    ...
}
```

而缓冲区是如何管理和分配的，就要看

```c
void main(void) {
    ...
    buffer_init(buffer_memory_end);
    ...
}
```











## 13.主内存初始化 mem_init

### 13.1 mem_init

具体主内存区是如何管理和分配的，要看 mem_init 里做了什么。

`init\main.c`

```c
void main(void) {
    ...
    mem_init(main_memory_start, memory_end);
    ...
}
```

进入 mem_init 函数。

`mm\memory.c`

```c
#define LOW_MEM 0x100000
#define PAGING_MEMORY (15*1024*1024)
#define PAGING_PAGES (PAGING_MEMORY>>12)
#define MAP_NR(addr) (((addr)-LOW_MEM)>>12)
#define USED 100

static long HIGH_MEMORY = 0;
static unsigned char mem_map[PAGING_PAGES] = { 0, };


// start_mem = 2 * 1024 * 1024
// end_mem = 8 * 1024 * 1024
void mem_init(long start_mem, long end_mem)
{
	int i;

	HIGH_MEMORY = end_mem;
	for (i=0 ; i<PAGING_PAGES ; i++)
		mem_map[i] = USED;
	i = MAP_NR(start_mem);
	end_mem -= start_mem;
	end_mem >>= 12;
	while (end_mem-->0)
		mem_map[i++]=0;
}
```

仔细一看这个方法，其实折腾来折腾去，就是给一个 **mem_map** 数组的各个位置上赋了值，而且显示全部赋值为 USED 也就是 100，然后对其中一部分又赋值为了 0。

赋值为 100 的部分就是 USED，也就表示内存被占用，如果再具体说是占用了 100 次，这个之后再说。剩下赋值为 0 的部分就表示未被使用，也即使用次数为零。

是不是很简单？**就是准备了一个表，记录了哪些内存被占用了，哪些内存没被占用**。这就是所谓的“管理”，并没有那么神乎其神。



那接下来自然有两个问题，每个元素表示占用和未占用，这个表示的范围是多大？初始化时哪些地方是占用的，哪些地方又是未占用的？

还是一张图就看明白了，我们仍然假设内存总共只有 8M。

![图片](assets/640-1705543755053-rs.png)

可以看出，初始化完成后，其实就是 mem_map 这个数组的每个元素都代表一个 **4K 内存**是否空闲（**准确说是使用次数**）。

4K 内存通常叫做 1 页内存，而这种管理方式叫**分页管理**，就是把内存分成一页**一页（4K）**的单位去管理。



**内存分布：**

- **内核代码区：**1M 以下的内存这个数组干脆没有记录，这里的内存是无需管理的，或者换个说法是无权管理的，也就是没有权利申请和释放，因为这个区域是内核代码所在的地方，不能被“污染”。
- **缓冲区：**1M 到 2M 这个区间。这些地方不是主内存区域，因此直接标记为 USED，产生的效果就是无法再被分配了。
- **主内存区域：**2M 以上的空间，主内存目前没有任何程序申请，所以初始化时统统都是零，未来等着应用程序去申请和释放这里的内存资源。







### Notes-应用程序申请内存

那应用程序如何申请内存呢？我们本讲不展开，不过我们简单展望一下，看看申请内存的过程中，是如何使用 mem_map 这个结构的。



在 `memory.c` 文件中有个函数 `get_free_page()`，用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。 

比如我们在 `fork` 子进程的时候，会调用 `copy_process` 函数来复制进程的结构信息，其中有一个步骤就是要**申请一页内存**，用于存放进程结构信息 `task_struct`。

```c
int copy_process(...) {
    struct task_struct *p;
    ...
    p = (struct task_struct *) get_free_page();
    ...
}
```

我们看 `get_free_page` 的具体实现，是内联汇编代码，看不懂不要紧，注意它里面就有 **mem_map** 结构的使用。

```c
unsigned long get_free_page(void) {
    register unsigned long __res asm("ax");
    __asm__(
        "std ; repne ; scasb\n\t"
        "jne 1f\n\t"
        "movb $1,1(%%edi)\n\t"
        "sall $12,%%ecx\n\t"
        "addl %2,%%ecx\n\t"
        "movl %%ecx,%%edx\n\t"
        "movl $1024,%%ecx\n\t"
        "leal 4092(%%edx),%%edi\n\t"
        "rep ; stosl\n\t"
        "movl %%edx,%%eax\n"
        "1:"
        :"=a" (__res)
        :"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
        "D" (mem_map + PAGING_PAGES-1)
        :"di","cx","dx");
    return __res;
}
```

就是选择 mem_map 中首个空闲页面，并标记为已使用。 









## 14.中断初始化 trap_init

### 14.1 trap_init 整体

我们以 **Linux 0.11** 源码为例，发现进入内核的 main 函数后不久，有这样一行代码。

`init\main.c`

```c
void main(void) {
    ...
    trap_init();
    ...
}
```

看到这个方法的全部代码后，你可能会会心一笑，也可能一脸懵逼。

`kernel\traps.c`

```c
void trap_init(void) {
    int i;
    set_trap_gate(0,&divide_error);
    set_trap_gate(1,&debug);
    set_trap_gate(2,&nmi);
    set_system_gate(3,&int3);   /* int3-5 can be called from all */
    set_system_gate(4,&overflow);
    set_system_gate(5,&bounds);
    set_trap_gate(6,&invalid_op);
    set_trap_gate(7,&device_not_available);
    set_trap_gate(8,&double_fault);
    set_trap_gate(9,&coprocessor_segment_overrun);
    set_trap_gate(10,&invalid_TSS);
    set_trap_gate(11,&segment_not_present);
    set_trap_gate(12,&stack_segment);
    set_trap_gate(13,&general_protection);
    set_trap_gate(14,&page_fault);
    set_trap_gate(15,&reserved);
    set_trap_gate(16,&coprocessor_error);
    for (i=17;i<48;i++)
        set_trap_gate(i,&reserved);
    set_trap_gate(45,&irq13);
    set_trap_gate(39,&parallel_interrupt);
}
```

这啥玩意？这么多 **set_xxx_gate**。



所以我就给他简化一下，把相同功能的去掉。

```c
void trap_init(void) {
    int i;
    // set 了一堆 trap_gate
    set_trap_gate(0, &divide_error);
    ... 
    // 又 set 了一堆 system_gate
    set_system_gate(45, &bounds);
    ...
    // 又又批量 set 了一堆 trap_gate
    for (i=17;i<48;i++)
        set_trap_gate(i, &reserved);
    ...
}
```







### 14.2 set_trap_gate & set_system_gate

首先我们看 **set_trap_gate** 和 **set_system_gate** 这俩货，发现了这么几个宏定义。

```c
#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ ("movw %%dx,%%ax\n\t" \
	"movw %0,%%dx\n\t" \
	"movl %%eax,%1\n\t" \
	"movl %%edx,%2" \
	: \
	: "i" ((short) (0x8000+(dpl<<13)+(type<<8))), \
	"o" (*((char *) (gate_addr))), \
	"o" (*(4+(char *) (gate_addr))), \
	"d" ((char *) (addr)),"a" (0x00080000))

#define set_trap_gate(n,addr) \
	_set_gate(&idt[n],15,0,addr)

#define set_system_gate(n,addr) \
	_set_gate(&idt[n],15,3,addr)
```

俩都是最终指向了相同的另一个宏定义 **_set_gate**。这段代码将汇编语言嵌入到 c 语言了，最终的效果就是**在中断描述符表中插入了一个中断描述符**。



idt（中断描述符表），这段代码就是往这个 idt 表里一项一项地写东西，其对应的**中断号**就是**第一个参数**，**中断处理程序**就是**第二个参数**。 

产生的效果就是，之后如果来一个**中断**后，CPU 根据其**中断号**，就可以到这个**中断描述符表 idt** 中找到对应的**中断处理程序**了。







### 14.3 set_trap_gate with reserved

再往后看，批量操作这里。

```c
void trap_init(void) {
    ...
    for (i=17;i<48;i++)
        set_trap_gate(i,&reserved);
    ...
}
```

17 到 48 号中断都批量设置为了 **reserved** 函数，这是暂时的，后面各个硬件初始化时要重新设置好这些中断，把暂时的这个给覆盖掉。



所以整段代码执行下来，内存中那个 idt 的位置会变成如下的样子。

![图片](assets/640-1705547090574-rs.png)







### Notes-中断举例

比如这个。

```c
set_trap_gate(0,&divide_error);
```

就是设置 **0 号中断**，对应的中断处理程序是 **divide_error**。

等 CPU 执行了一条除零指令的时候，会从硬件层面发起一个 0 号异常中断，然后执行由我们操作系统定义的 divide_error 也就是除法异常处理程序，执行完之后再返回。



再比如这个。

```c
set_system_gate(5,&overflow);
```

就是设置 5 号中断，对应的中断处理程序是 overflow，是边界出错中断。

[^TIPS]: 这个 trap 与 system 的区别仅仅在于，设置的中断描述符的特权级不同，前者是 0（内核态），后者是 3（用户态）







## 15.块设备请求项初始化 blk_dev_init

### 15.1 request 初始化

读取**块设备**与**内存缓冲区**之间的桥梁，**块设备请求项**的初始化工作。

[^Tips]: 读取硬盘需要有块设备驱动程序，而以文件的方式来读取则还有要再上面包一层文件系统。把读出来的数据放到内存，就涉及到内存中缓冲区的管理。

`init\main.c`

```c
void main(void) {
    ...
    blk_dev_init();
    ...
}
```

看到这个方法的全部代码后

`kernel\blk_drv\ll_rw_blk.c`

```c
void blk_dev_init(void) {
    int i;
    for (i=0; i<32; i++) {
        request[i].dev = -1;
        request[i].next = NULL;
    }
}
```

就是给 request 这个数组的前 32 个元素的两个变量 **dev** 和 **next** 附上值，看这俩值 **-1** 和 **NULL** 也可以大概猜出，这是没有任何作用时的初始化值。



看下 request 结构体。

```c
/*
 * Ok, this is an expanded form so that we can use the same
 * request for paging requests when that is implemented. In
 * paging, 'bh' is NULL, and 'waiting' is used to wait for
 * read/write completion.
 */
struct request {
	int dev;		/* -1 if no request */
	int cmd;		/* READ or WRITE */
	int errors;
	unsigned long sector;
	unsigned long nr_sectors;
	char * buffer;
	struct task_struct * waiting;
	struct buffer_head * bh;
	struct request * next;
};
```

这个结构就代表了一次读盘请求，其中：

- `dev` 表示设备号，-1 就表示空闲。
- `cmd` 表示命令，其实就是 READ 还是 WRITE，也就表示本次操作是读还是写。
- `errors` 表示操作时产生的错误次数。
- `sector` 表示起始扇区。
- `nr_sectors` 表示扇区数。
- `buffer`表示数据缓冲区，也就是读盘之后的数据放在内存中的什么位置。
- `waiting` 是个 task_struct 结构，这可以表示一个进程，也就表示是哪个进程发起了这个请求。
- `bh`是缓冲区头指针，这个后面讲完缓冲区就懂了，因为这个 request 是需要与缓冲区挂钩的。
- `next` 指向了下一个请求项。



可以基于现有`request`的重点参数猜测一下，比如读请求时，**cmd** 就是 READ，**sector** 和 **nr_sectors** 这俩就定位了所要读取的块设备（可以简单先理解为硬盘）的哪几个扇区，**buffer** 就定位了这些数据读完之后放在内存的什么位置。

这就够啦，想想看，这四个参数是不是就能完整描述了一个读取硬盘的需求了？而且完全没有歧义，就像下面这样。

![图片](../../%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/640-1705548123479-rs.png)

而其他的参数，肯定是为了更好地配合操作系统进行读写块设备操作嘛，为了把多个读写块设备请求很好地组织起来。这个组织不但要有这个数据结构中 hb 和 next 等变量的配合，还要有后面的电梯调度算法的配合，仅此而已，先点到为止。



总之，我们这里就先明白，这个 request 结构可以完整描述一个读盘操作。然后那个 request 数组就是把它们都放在一起，并且它们又通过 next 指针串成链表。

![图片](../../%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/assets/640-1705548215012-rs.png)

好，本文讲述的两行代码，其实就完成了上图所示的工作而已

通过 `blk_dev_init` 为后面的**块设备**访问，提前**建立了一个数据结构(request)**，作为访问**块设备**和**内存缓冲区**之间的桥梁，就可以了。







### Notes-读盘的全流程&request[NR_REQUEST]使用

简单展望一下，读盘的全流程中，是怎么用到刚刚初始化的这个 `request[NR_REQUEST]` 结构的。

读操作的系统调用函数是 **sys_read**，源代码很长，我给简化一下，仅仅保留读取普通文件的分支，就是如下的样子。

`fs\read_write.c`

```c
int sys_read(unsigned int fd,char * buf,int count) {
    struct file * file = current->filp[fd];
    struct m_inode * inode = file->f_inode;
    // 校验 buf 区域的内存限制
    verify_area(buf,count);
    // 仅关注目录文件或普通文件
    return file_read(inode,file,buf,count);
}
```

看，入参 **fd** 是文件描述符，通过它可以找到一个文件的 inode，进而找到这个文件在硬盘中的位置。

![图片](assets/640-1705548881359-rs.png)

另两个入参 **buf** 就是要复制到的内存中的位置，**count** 就是要复制多少个字节，很好理解。

钻到 file_read 函数里继续看。

`fs\file_dev.c`

```c
int file_read(struct m_inode * inode, struct file * filp, char * buf, int count) {
    int left,chars,nr;
    struct buffer_head * bh;
    left = count;
    while (left) {
        if (nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE)) {
            if (!(bh=bread(inode->i_dev,nr)))
                break;
        } else
            bh = NULL;
        nr = filp->f_pos % BLOCK_SIZE;
        chars = MIN( BLOCK_SIZE-nr , left );
        filp->f_pos += chars;
        left -= chars;
        if (bh) {
            char * p = nr + bh->b_data;
            while (chars-->0)
                put_fs_byte(*(p++),buf++);
            brelse(bh);
        } else {
            while (chars-->0)
                put_fs_byte(0,buf++);
        }
    }
    inode->i_atime = CURRENT_TIME;
    return (count-left)?(count-left):-ERROR;
}
```

整体看，就是一个 while 循环，每次读入一个块的数据，直到入参所要求的大小全部读完为止。



直接看 `bread` 那一行。这个函数就是去读某一个设备的某一个数据块号的内容，展开进去看。

`fs\buffer.c`

```c
/*
 * bread() reads a specified block and returns the buffer that contains
 * it. It returns NULL if the block was unreadable.
 */
struct buffer_head * bread(int dev,int block)
{
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))
		panic("bread: getblk returned NULL\n");
	if (bh->b_uptodate)
		return bh;
	ll_rw_block(READ,bh);
	wait_on_buffer(bh);
	if (bh->b_uptodate)
		return bh;
	brelse(bh);
	return NULL;
}
```

其中 `getblk` 先申请了一个内存中的缓冲块，然后 `ll_rw_block` 负责把数据读入这个缓冲块，进去继续看。

`kernel\blk_drv\ll_rw_blk.c`

```c
void ll_rw_block(int rw, struct buffer_head * bh) {
    ...
    make_request(major,rw,bh);
}

static void make_request(int major,int rw, struct buffer_head * bh) {
    ...
if (rw == READ)
        req = request+NR_REQUEST;
    else
        req = request+((NR_REQUEST*2)/3);
/* find an empty request */
    while (--req >= request)
        if (req->dev<0)
            break;
    ...
/* fill up the request-info, and add it to the queue */
    req->dev = bh->b_dev;
    req->cmd = rw;
    req->errors=0;
    req->sector = bh->b_blocknr<<1;
    req->nr_sectors = 2;
    req->buffer = bh->b_data;
    req->waiting = NULL;
    req->bh = bh;
    req->next = NULL;
    add_request(major+blk_dev,req);
}
```

看，这里就用到了刚刚说的结构咯。 

具体说来，就是该函数会往刚刚的设备的请求项链表 `request[32]` 中添加一个请求项，只要 request[32] 中有未处理的请求项存在，都会陆续地被处理，直到设备的请求项链表是空为止。

具体怎么读盘，就是与硬盘 IO 端口进行交互的过程了，可以继续往里跟，直到看到一个 hd_out 函数为止，本讲不展开了。









## 16.控制台初始化 tty_init

### 16.1 整体代码

我们继续往下看，tty_init。

`init\main.c`

```c
void main(void) {
    ...
    tty_init();
    ...
}
```

打开这个函数

`kernel\chr_drv\tty_io.c`

```c
void tty_init(void)
{
	rs_init();
	con_init();
}
```







### 16.2 rs_init

打开第一个方法，还好。

`kernel\chr_drv\serial.c`

```c
void rs_init(void)
{
	set_intr_gate(0x24,rs1_interrupt);
	set_intr_gate(0x23,rs2_interrupt);
	init(tty_table[1].read_q.data);
	init(tty_table[2].read_q.data);
	outb(inb_p(0x21)&0xE7,0x21);
}
```

这个方法是串口中断的开启，以及设置对应的中断处理程序，串口在我们现在的 PC 机上已经很少用到了，所以这个直接忽略。







### 16.3 con_init

看第二个方法，这是重点。代码非常长，有点吓人，我先把大体框架写出。

`kernel\chr_drv\console.c`

```c
void con_init(void) {
    ...
    if (ORIG_VIDEO_MODE == 7) {
        ...
        if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {...}
        else {...}
    } else {
        ...
        if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10) {...}
        else {...}
    }
    ...
}
```

可以看出，非常多的 if else。



这是为了**应对不同的显示模式，来分配不同的变量值**，那如果我们仅仅找出一个显示模式，这些分支就可以只看一个了。

我们就假设显示模式是我们现在的这种文本模式，那条件分支就可以去掉好多。

代码可以简化成这个样子。

`kernel\chr_drv\console.c`

```c
#define ORIG_X          (*(unsigned char *)0x90000)
#define ORIG_Y          (*(unsigned char *)0x90001)
void con_init(void) {
    register unsigned char a;
    // 第一部分 获取显示模式相关信息
    video_num_columns = (((*(unsigned short *)0x90006) & 0xff00) >> 8);
    video_size_row = video_num_columns * 2;
    video_num_lines = 25;
    video_page = (*(unsigned short *)0x90004);
    video_erase_char = 0x0720;
    // 第二部分 显存映射的内存区域 
    video_mem_start = 0xb8000;
    video_port_reg  = 0x3d4;
    video_port_val  = 0x3d5;
    video_mem_end = 0xba000;
    // 第三部分 滚动屏幕操作时的信息
    origin  = video_mem_start;
    scr_end = video_mem_start + video_num_lines * video_size_row;
    top = 0;
    bottom  = video_num_lines;
    // 第四部分 定位光标并开启键盘中断
    gotoxy(ORIG_X, ORIG_Y);
    set_trap_gate(0x21,&keyboard_interrupt);
    outb_p(inb_p(0x21)&0xfd,0x21);
    a=inb_p(0x61);
    outb_p(a|0x80,0x61);
    outb(a,0x61);
}
```

- **第一部分**获取 0x90006 地址处的数据，就是获取显示模式等相关信息。
- **第二部分**就是**显存映射的内存地址范围**，我们现在假设是 CGA 类型的文本模式，所以映射的内存是从 0xB8000 到 0xBA000。
- **第三部分**是设置一些滚动屏幕时需要的参数，定义顶行和底行是哪里，这里顶行就是第一行，底行就是最后一行，很合理。
- **第四部分**是把光标定位到之前保存的光标位置处（取内存地址 0x90000 处的数据），然后设置并开启键盘中断。

开启键盘中断后，键盘上敲击一个按键后就会触发中断，中断程序就会读键盘码转换成 ASCII 码，然后写到光标处的内存地址，也就相当于往显存写，于是这个键盘敲击的字符就显示在了屏幕上。

![图片](assets/640.gif)









### 16.4 Notes-键盘输入到屏幕输出详解

这一切具体是怎么做到的呢？我们先看看我们干了什么。 

1. 我们现在根据已有信息已经可以实现往屏幕上的任意位置写字符了，而且还能指定颜色。
2. 并且，我们也能接受键盘中断，根据键盘码中断处理程序就可以得知哪个键按下了。

有了这俩功能，那我们想干嘛还不是为所欲为？



好，接下来我们看看代码是怎么处理的，很简单。一切的起点，就是第四步的 **gotoxy** 函数，定位当前光标。

```c
#define ORIG_X          (*(unsigned char *)0x90000)
#define ORIG_Y          (*(unsigned char *)0x90001)
void con_init(void) {
    ...
    // 第四部分 定位光标并开启键盘中断
    gotoxy(ORIG_X, ORIG_Y);
    ...
}
```

这里面干嘛了呢？

`kernel\chr_drv\console.c`

```c
static inline void gotoxy(unsigned int new_x,unsigned int new_y) {
   ...
   x = new_x;
   y = new_y;
   pos = origin + y*video_size_row + (x<<1);
}
```

就是给 **x y pos** 这三个参数附上了值。

其中 **x** 表示光标在哪一列，**y** 表示光标在哪一行，**pos** 表示根据列号和行号计算出来的内存指针，也就是往这个 pos 指向的地址处写数据，就相当于往控制台的 x 列 y 行处写入字符了，简单吧？



然后，当你按下键盘后，触发键盘中断，之后的程序调用链是这样的。

```c
_keyboard_interrupt:
    ...
    call _do_tty_interrupt
    ...
    
void do_tty_interrupt(int tty) {
   copy_to_cooked(tty_table+tty);
}

void copy_to_cooked(struct tty_struct * tty) {
    ...
    tty->write(tty);
    ...
}

// 控制台时 tty 的 write 为 con_write 函数
void con_write(struct tty_struct * tty) {
    ...
    __asm__("movb _attr,%%ah\n\t"
      "movw %%ax,%1\n\t"
      ::"a" (c),"m" (*(short *)pos)
      :"ax");
     pos += 2;
     x++;
    ...
}
```

前面的过程不用管，我们看最后一个函数 con_write 中的关键代码。

__asm__ 内联汇编，就是把键盘输入的字符 **c** 写入 **pos** 指针指向的内存，相当于往屏幕输出了。 

之后两行 pos+=2 和 x++，就是调整所谓的**光标**。

你看，写入一个字符，最底层，**其实就是往内存的某处写个数据，然后顺便调整一下光标**。

由此我们也可以看出，光标的本质，其实就是这里的 `x, y, pos` 这仨变量而已。

我们还可以做**换行效果**，当发现光标位置处于某一行的结尾时（这个应该很好算吧，我们都知道屏幕上一共有几行几列了），就把光标计算出一个新值，让其处于下一行的开头。

![图片](assets/640-1705646743085.gif)

就一个小计算公式即可搞定，仍然在 con_write 源码处有体现，就是判断列号 x 是否大于了总列数。

`kernel\chr_drv\console.c`

```c
void con_write(struct tty_struct * tty) {
    ...
    if (x>=video_num_columns) {
        x -= video_num_columns;
        pos -= video_size_row;
        lf();
  }
  ...
}

static void lf(void) {
   if (y+1<bottom) {
      y++;
      pos += video_size_row;
      return;
   }
 ...
}
```

相似的，我们还可以实现**滚屏**的效果，无非就是当检测到光标已经出现在最后一行最后一列了，那就把每一行的字符，都复制到它上一行，其实就是算好哪些内存地址上的值，拷贝到哪些内存地址，就好了。



所以，有了这个初始化工作，我们就可以利用这些信息，弄几个小算法，实现各种我们常见控制台的操作。

或者换句话说，我们见惯不怪的控制台，**回车**、**换行**、**删除**、**滚屏**、**清屏**等操作，其实底层都要实现相应的代码的。

所以 console.c 中的其他方法就是做这个事的，我们就不展开每一个功能的方法体了，简单看看有哪些方法。

`kernel\chr_drv\console.c`

```c
// 定位光标的
static inline void gotoxy(unsigned int new_x, unsigned int new_y){}
// 滚屏，即内容向上滚动一行
static void scrup(void){}
// 光标同列位置下移一行
static void lf(int currcons){}
// 光标回到第一列
static void cr(void){}
...
// 删除一行
static void delete_line(void){}
```

内容繁多，但没什么难度，只要理解了基本原理即可了。











### Notes-显示模式

啥是显示模式呢？那我们得简单说说显示，**一个字符是如何显示在屏幕上的呢**？换句话说，如果你可以随意操作内存和 CPU 等设备，你如何操作才能使得你的显示器上，显示一个字符`‘a’`呢？



我们先看一张图。

![图片](assets/640-1705645045737-rs.png)

**内存**中有这样一部分区域，是和**显存**映射的。啥意思，就是你往上图的这些内存区域中写数据，相当于写在了显存中。而往显存中写数据，就相当于在屏幕上输出文本了。

没错，就是这么简单。

如果我们写这一行汇编语句。

```assembly
mov [0xB8000],'h'
```

后面那个 h 相当于汇编编辑器帮我们转换成 ASCII 码的二进制数值，当然我们也可以直接写。

```assembly
mov [0xB8000],0x68
```

其实就是往内存中 **0xB8000** 这个位置写了一个值，只要一写，屏幕上就会是这样。

![图片](assets/640-1705645293472.png)

简单吧，具体说来，这片内存是每两个字节表示一个显示在屏幕上的字符，**第一个是字符的编码，第二个是字符的颜色**，那我们先不管颜色，如果多写几个字符就像这样。

```assembly
mov [0xB8000],'h'
mov [0xB8002],'e'
mov [0xB8004],'l'
mov [0xB8006],'l'
mov [0xB8008],'o'
```

此时屏幕上就会是这样。

![图片](assets/640-1705645390958.png)











## 17.时间初始化 time_init

### 17.1 整体代码

我们继续往下看下一个初始化的倒霉鬼，**time_init**。

`init\main.c`

```c
void main(void) {
    ...
    time_init();
    ...
}
```

**操作系统是怎么获取到当前时间的呢**？打开这个 **time_init** 函数一探究竟。

```c
#define CMOS_READ(addr) ({ \
outb_p(0x80|addr,0x70); \
inb_p(0x71); \
})

#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)

static void time_init(void)
{
	struct tm time;

	do {
		time.tm_sec = CMOS_READ(0);
		time.tm_min = CMOS_READ(2);
		time.tm_hour = CMOS_READ(4);
		time.tm_mday = CMOS_READ(7);
		time.tm_mon = CMOS_READ(8);
		time.tm_year = CMOS_READ(9);
	} while (time.tm_sec != CMOS_READ(0));
	BCD_TO_BIN(time.tm_sec);
	BCD_TO_BIN(time.tm_min);
	BCD_TO_BIN(time.tm_hour);
	BCD_TO_BIN(time.tm_mday);
	BCD_TO_BIN(time.tm_mon);
	BCD_TO_BIN(time.tm_year);
	time.tm_mon--;
	startup_time = kernel_mktime(&time);
}
```

那主要就是对 **CMOS_READ** 和 **BCD_TO_BIN** 都是啥意思展开讲一下就明白了了。







### 17.2 CMOS_READ

首先是 **CMOS_READ**

`init\main.c`

```c
#define CMOS_READ(addr) ({ \
    outb_p(0x80|addr,0x70); \
    inb_p(0x71); \
})
```

就是对一个端口先 **out** 写一下，再 **in** 读一下。

这是 CPU 与外设交互的一个基本玩法，**CPU 与外设打交道基本是通过端口，往某些端口写值来表示要这个外设干嘛，然后从另一些端口读值来接受外设的反馈。**

至于这个外设内部是怎么实现的，对使用它的操作系统而言，是个黑盒，无需关心。那对于我们程序员来说，就更不用关心了。

 **CMOS**它是主板上的一个可读写的 RAM 芯片，你在开机时长按某个键就可以进入设置它的页面。

![图片](assets/640.jfif)

那我们的代码，其实就是与它打交道，获取它的一些数据而已。



我们回过头看代码。

```c
static void time_init(void) {
    struct tm time;
    do {
        time.tm_sec = CMOS_READ(0);
        time.tm_min = CMOS_READ(2);
        time.tm_hour = CMOS_READ(4);
        time.tm_mday = CMOS_READ(7);
        time.tm_mon = CMOS_READ(8);
        time.tm_year = CMOS_READ(9);
    } while (time.tm_sec != CMOS_READ(0));
    BCD_TO_BIN(time.tm_sec);
    BCD_TO_BIN(time.tm_min);
    BCD_TO_BIN(time.tm_hour);
    BCD_TO_BIN(time.tm_mday);
    BCD_TO_BIN(time.tm_mon);
    BCD_TO_BIN(time.tm_year);
    time.tm_mon--;
    startup_time = kernel_mktime(&time);
}
```

前面几个赋值语句 **CMOS_READ** 就是通过读写 CMOS 上的指定端口，依次获取**年月日时分秒**等信息。具体咋操作代码上也写了，也是按照 CMOS 手册要求的读写指定端口就行了，我们就不展开了。

其实操作系统程序，也是要依靠与一个外部设备打交道，来获取这些信息的，并不是它自己有什么魔力。操作系统最大的魅力，就在于它借力完成了一项伟大的事，借 CPU 的力，借硬盘的力，借内存的力，以及现在借 CMOS 的力。







### 17.3 BCD_TO_BIN

接下来 **BCD_TO_BIN** 就是 BCD 转换成 BIN，因为从 CMOS 上获取的这些年月日都是 BCD 码值，需要转换成存储在我们变量上的二进制数值，所以需要一个小算法来转换一下，没什么意思。

```c
#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
```







### 17.4 kernel_mktime

最后一步 **kernel_mktime** 也很简单，就是根据刚刚的那些时分秒数据，计算从 **1970 年 1 月 1 日 0 时**起到开机当时经过的秒数，作为开机时间，存储在 **startup_time** 这个变量里。

`kernel\mktime.c`

```c
startup_time = kernel_mktime(&time);


// kernel/mktime.c
long kernel_mktime(struct tm * tm)
{
	long res;
	int year;

	year = tm->tm_year - 70;
/* magic offsets (y+1) needed to get leapyears right.*/
	res = YEAR*year + DAY*((year+1)/4);
	res += month[tm->tm_mon];
/* and (y+2) here. If it wasn't a leap-year, we have to adjust */
	if (tm->tm_mon>1 && ((year+2)%4))
		res -= DAY;
	res += DAY*(tm->tm_mday-1);
	res += HOUR*tm->tm_hour;
	res += MINUTE*tm->tm_min;
	res += tm->tm_sec;
	return res;
}
```

所以今天其实就是，计算出了一个 **startup_time** 变量而已，至于这个变量今后会被谁用，怎么用，那就是后话了。







### Notes-CPU与外设交换举例

CPU与外设的交互，最常见的就是读硬盘了，我们看硬盘的端口表。

| 端口  | 读                               | 写                               |
| ----- | -------------------------------- | -------------------------------- |
| 0x1F0 | 数据寄存器                       | 数据寄存器                       |
| 0x1F1 | 错误寄存器                       | 特征寄存器                       |
| 0x1F2 | 扇区计数寄存器                   | 扇区计数寄存器                   |
| 0x1F3 | 扇区号寄存器或 LBA 块地址 0~7    | 扇区号或 LBA 块地址 0~7          |
| 0x1F4 | 磁道数低 8 位或 LBA 块地址 8~15  | 磁道数低 8 位或 LBA 块地址 8~15  |
| 0x1F5 | 磁道数高 8 位或 LBA 块地址 16~23 | 磁道数高 8 位或 LBA 块地址 16~23 |
| 0x1F6 | 驱动器/磁头或 LBA 块地址 24~27   | 驱动器/磁头或 LBA 块地址 24~27   |
| 0x1F7 | 命令寄存器或状态寄存器           | 命令寄存器                       |

那读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 0x1F0 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。



如果觉得不够具体，那来个具体的版本。

1. 在 0x1F2 写入要读取的扇区数
2. 在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址
3. 在 0x1F7 处写入读命令的指令号
4. 不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位
5. 如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完

看，是不是对 CPU 最底层是如何与外设打交道有点感觉了？是不是也不难？就是按照人家的操作手册，然后无脑按照要求读写端口就行了。

当然，读取硬盘的这个无脑循环，可以 **CPU** 直接读取并做写入内存的操作，这样就会占用 CPU 的计算资源。

也可以交给 **DMA** 设备去读，解放 CPU，但和硬盘的交互，通通都是按照硬件手册上的端口说明，来操作的，实际上也是做了一层封装。









## 18.进程调度初始化 sched_init

### 18.1 整体

我们继续往下看，大名鼎鼎的进程调度初始化，**shed_init**。

`init\main.c`

```c
void main(void) {
    ...
    sched_init();
    ...
}
```

这方法可了不起，因为它就是多进程的基石！

这里只是进程调度的初始化，也就是为进程调度所需要用到的数据结构做个准备，真正的进程调度还需要调度算法、时钟中断等机制的配合。 

当然，对于理解操作系统，流程和数据结构最为重要了，而这一段作为整个流程的起点，以及建立数据结构的地方，就显得格外重要了。







### 18.2 TSS & LDT初始化

我们进入这个方法，一点点往后看。

`kernel\sched.c`

```c
void sched_init(void) {
    set_tss_desc(gdt+4, &(init_task.task.tss));
    set_ldt_desc(gdt+5, &(init_task.task.ldt));
    ...
}
```

两行代码初始化了下 **TSS** 和 **LDT**。

先别急问这俩结构是啥。还记得之前讲的全局描述符表 gdt 么？它在内存的这个位置，并且被设置成了这个样子。

![图片](assets/640-1705652063694-rs.png)

说回这**两行代码，其实就是往后又加了两项，分别是 TSS 和 LDT。**

![图片](assets/640-1705652133190-rs.png)

好，那再说说这俩结构是干嘛的，不过本篇先简单理解，后面会详细讲到。

- `TSS` 叫**任务状态段**，就是**保存和恢复进程的上下文的**，所谓上下文，其实就是各个寄存器的信息而已，这样进程切换的时候，才能做到保存和恢复上下文，继续执行。

  由它的数据结构你应该可以看出点意思。

  ```c
  struct tss_struct{
      long back_link;
      long esp0;
      long ss0;
      long esp1;
      long ss1;
      long esp2;
      long ss2;
      long cr3;
      long eip;
      long eflags;
      long eax, ecx, edx, ebx;
      long esp;
      long ebp;
      long esi;
      long edi;
      long es;
      long cs;
      long ss;
      long ds;
      long fs;
      long gs;
      long ldt;
      long trace_bitmap;
      struct i387_struct i387;
  };
  ```

- `LDT` 叫**局部描述符表**，是与 **GDT 全局描述符表**相对应的，**内核态的代码**用 **GDT 里的数据段和代码段**，而**用户进程的代码**用每个用户进程自己的 **LDT 里得数据段和代码段。**



这里放一张超纲的图，你先找找感觉

![图片](assets/640-1705652390720.png)









### 18.3 task数组初始化 & gdt填充

我们接着往下看。

`kernel\sched.c`

```c
struct desc_struct {
    unsigned long a,b;
}

struct task_struct * task[64] = {&(init_task.task), };

void sched_init(void) {
    ...
    int i;
    struct desc_struct * p;
        p = gdt+6;
    for(i=1;i<64;i++) {
        task[i] = NULL;
        p->a=p->b=0;
        p++;
        p->a=p->b=0;
        p++;
    }
    ...
}
```

这段代码有个循环，干了两件事。

1. 一个是给一个长度为 64，元素为 `task_struct *`的数组 `task` 附上初始值。

   ![图片](assets/640-1705652906044-rs.png)

   这个 `task_struct` 结构就是代表**每一个进程的信息**，这可是个相当相当重要的结构了，把它放在心里。

   ```c
   struct task_struct {
   /* these are hardcoded - don't touch */
       long state; /* -1 unrunnable, 0 runnable, >0 stopped */
       long counter;
       long priority;
       long signal;
       struct sigaction sigaction[32];
       long blocked; /* bitmap of masked signals */
     /* various fields */
       int exit_code;
       unsigned long start_code,end_code,end_data,brk,start_stack;
       long pid,father,pgrp,session,leader;
       unsigned short uid,euid,suid;
       unsigned short gid,egid,sgid;
       long alarm;
       long utime,stime,cutime,cstime,start_time;
       unsigned short used_math;
     /* file system info */
       int tty;  /* -1 if no tty, so it must be signed */
       unsigned short umask;
       struct m_inode * pwd;
       struct m_inode * root;
       struct m_inode * executable;
       unsigned long close_on_exec;
       struct file * filp[NR_OPEN];
     /* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
       struct desc_struct ldt[3];
     /* tss for this task */
       struct tss_struct tss;
   };
   ```

2. 另一件事，是给 gdt 剩下的位置填充上 0，也就是把剩下留给 TSS 和 LDT 的描述符都先附上空值。

   ![图片](assets/640-1705653163265-rs.png)

往后展望一下的话，就是以后**每创建一个新进程，就会在后面添加一组 TSS 和 LDT** 表示这个进程的**任务状态段**以及**局部描述符表**信息。



那为什么一开始就先有了一组 TSS 和 LDT 呢？现在也没创建进程呀。错了，现在虽然我们还没有建立起进程调度的机制，但我们正在运行的代码就是会作为**未来的一个进程的指令流**。

也就是当未来进程调度机制一建立起来，正在执行的代码就会化身成为**进程 0** 的代码。所以我们需要提前把这些未来会作为进程 0 的信息写好。







### 18.4 tr & ldt寄存器初始化

好，收回来，初始化了一组 TSS 和 LDT 后，再往下看两行。

```c
#define ltr(n) __asm__("ltr %%ax"::"a" (_TSS(n)))
#define lldt(n) __asm__("lldt %%ax"::"a" (_LDT(n)))

void sched_init(void) {
    ...
    ltr(0);
    lldt(0);
    ...
}
```

这又涉及到之前的知识咯。

还记得 **lidt** 和 **lgdt** 指令么？一个是给 idtr 寄存器赋值，以告诉 CPU 中断描述符表 idt 在内存的位置；一个是给 gdtr 寄存器赋值，以告诉 CPU 全局描述符表 gdt 在内存的位置。

那这两行和刚刚的类似:

- **ltr** 是给 **tr** 寄存器赋值，以告诉 CPU 任务状态段 TSS 在内存的位置；
- **lldt** 一个是给 **ldt** 寄存器赋值，以告诉 CPU 局部描述符 LDT 在内存的位置。

![图片](assets/640-1705653523994-rs.png)

这样，CPU 之后就能通过 `tr 寄存器`找到当前进程的任务状态段信息，也就是上下文信息，以及通过 `ldt 寄存器`找到当前进程在用的局部描述符表信息。 







### 18.5 时钟中断&系统调用中断设置

我们继续看。

```c
void sched_init(void) {
    ...
    outb_p(0x36,0x43);      /* binary, mode 3, LSB/MSB, ch 0 */
    outb_p(LATCH & 0xff , 0x40);    /* LSB */
    outb(LATCH >> 8 , 0x40);    /* MSB */
    set_intr_gate(0x20,&timer_interrupt);
    outb(inb_p(0x21)&~0x01,0x21);
    set_system_gate(0x80,&system_call);
    ...
}
```

四行端口读写代码，两行设置中断代码。

端口读写我们已经很熟悉了，就是 CPU 与外设交互的一种方式，之前讲硬盘读写以及 CMOS 读写时，已经接触过了。 



而这次交互的外设是一个**可编程定时器**的芯片，这四行代码就开启了这个定时器，之后这个定时器便会**持续的、以一定频率的向 CPU 发出中断信号**。

![图片](assets/640-1705653949104.gif)

而这段代码中设置的两个中断：

1. 第一个就是**时钟中断**，中断号为 **0x20**，中断处理程序为 **timer_interrupt**。那么每次定时器向 CPU 发出中断后，便会执行这个函数。

   ```c
   // 这个定时器的触发，以及时钟中断函数的设置，是操作系统主导进程调度的一个关键！没有他们这样的外部信号不断触发中断，操作系统就没有办法作为进程管理的主人，通过强制的手段收回进程的 CPU 执行权限。
   ```

2. 第二个设置的中断叫系统调用 **system_call**，中断号是 **0x80**，这个中断又是个非常非常非常非常非常非常非常重要的中断，所有**用户态程序**想要**调用内核提供的方法**，都需要**基于这个系统调用**来进行。









### Notes-到目前设置的中断函数

到目前为止，中断已经设置了不少了，我们现在看看所设置好的中断有哪些。

| 中断号   | 中断处理函数           |
| -------- | ---------------------- |
| 0 ~ 0x10 | trap_init 里设置的一堆 |
| 0x20     | timer_interrupt        |
| 0x21     | keyboard_interrupt     |
| 0x80     | system_call            |

-  其中**0-0x10** 这 17 个中断是 trap_init 里初始化设置的，是一些基本的中断，比如除零异常等。
- 之后，在控制台初始化 con_init 里，我们又设置了 **0x21** 键盘中断，这样按下键盘就有反应了。
- 现在，我们又设置了 **0x20** 时钟中断，并且开启定时器。
- 最后又偷偷设置了一个极为重要的 **0x80** 系统调用中断。



找到些感觉没，有没有越来越发现，**操作系统有点靠中断驱动的意思**，各个模块不断初始化各种中断处理函数，并且开启指定的外设开关，让操作系统自己慢慢“活”了起来，逐渐通过中断忙碌于各种事情中，无法自拔。









## 19.缓冲区初始化 buffer_init

### 19.1 整体代码

回到 main 函数，继续看下一个初始化的过程。那就是缓冲区初始化 buffer_init。

`init\main.c`

```c
void main(void) {
    ...
    buffer_init(buffer_memory_end);
    ...
}
```

首先要注意到，这个函数传了个参数 buffer_memory_end，这个是在老早之前就设置好的

![图片](assets/640-1705655986911-rs.png)

今天就是把剩下的**缓冲区部分，也初始化管理起来**。

我们还是采用之前的方式，就假设内存只有 8M，把一些不相干的分支去掉，方便理解。

`fs\buffer.c`

```c
extern int end;
struct buffer_head * start_buffer = (struct buffer_head *) &end;

void buffer_init(long buffer_end) {
    struct buffer_head * h = start_buffer;
    void * b = (void *) buffer_end;
    while ( (b -= 1024) >= ((void *) (h+1)) ) {
        h->b_dev = 0;
        h->b_dirt = 0;
        h->b_count = 0;
        h->b_lock = 0;
        h->b_uptodate = 0;
        h->b_wait = NULL;
        h->b_next = NULL;
        h->b_prev = NULL;
        h->b_data = (char *) b;
        h->b_prev_free = h-1;
        h->b_next_free = h+1;
        h++;
    }
    h--;
    free_list = start_buffer;
    free_list->b_prev_free = h;
    h->b_next_free = free_list;
    for (int i=0;i<307;i++)
        hash_table[i]=NULL;
}
```

虽然很长，但其实就造了**两个数据结构**而已。







### 19.2 外部变量end & start_buffer

不过别急，我们先看这一行代码。

```c
extern int end;
void buffer_init(long buffer_end) {
    struct buffer_head * start_buffer = (struct buffer_head *) &end;
    ...
}
```

这里有个外部变量 **end**，而我们的缓冲区开始位置 **start_buffer** 就等于这个变量的内存地址。

这个外部变量 end 并不是操作系统代码写就的，而是由**链接器 ld** 在链接整个程序时设置的一个外部变量，帮我们计算好了整个内核代码的末尾地址。

那在这之前的是内核代码区域肯定不能用，在这之后的，就给 buffer 用了。所以我们的内存分布图可以更精确一点了。

![图片](assets/640-1705656977555-rs.png)

你看，之前的疑惑解决了吧？很好理解嘛，内核程序和缓冲区的划分，肯定有个分界线，这个分界线就是 end 变量的值。

[^关于end取值]: 这个值定多少合适呢？ 像主内存和缓冲区的分界线，就直接代码里写死了，就是上图中的 2M。 可是内核程序占多大内存在写的时候完全不知道，就算知道了如果改动一点代码也会变化，所以就由程序编译链接时由链接器程序帮我们把这个内核代码末端的地址计算出来，作为一个外部变量 end 我们拿来即用，就方便多了。







### 19.3 缓冲头&缓冲块构建

**整段代码创造了哪两个管理结构**？

我们先看这段结构。

```c
void buffer_init(long buffer_end) {
    struct buffer_head * h = start_buffer;
    void * b = (void *) buffer_end;
    while ( (b -= 1024) >= ((void *) (h+1)) ) {
        ...
        h->b_data = (char *) b;
        h->b_prev_free = h-1;
        h->b_next_free = h+1;
        h++;
    }
    ...
}
```

就俩变量。

一个是 **buffer_head** 结构的 **h**，代表缓冲头，其指针值是 start_buffer，刚刚我们计算过了，就是图中的内核代码末端地址 end，也就是缓冲区开头。

一个是 **b**，代表缓冲块，指针值是 buffer_end，也就是图中的 2M，就是缓冲区结尾。

缓冲区结尾的 b 每次循环 -1024，也就是一页的值，缓冲区结尾的 h 每次循环 +1（一个 buffer_head 大小的内存），直到碰一块为止。

![图片](assets/640-1705889127316-rs.png)

可以看到，其实这个 b 就代表缓冲块，h 代表缓冲头，一个从上往下，一个从下往上。

而且这个过程中，h 被附上了属性值，其中比较关键的是这个 buffer 所表示的数据部分 **b_data**，也就是指向了上面的缓冲块 b。 

还有这个 buffer 的前后空闲 buffer 的指针 **b_prev_free** 和 **b_next_free**。

那画成图就是如下这样。

![图片](assets/640-1705889452129-rs.png)

当缓冲头 h 的所有 next 和 prev 指针都指向彼此时，就构成了一个双向链表。







### 19.4 全局指针变量free_list

继续看。

```c
void buffer_init(long buffer_end) {
    ...
    free_list = start_buffer;
    free_list->b_prev_free = h;
    h->b_next_free = free_list;
    ...
}
```

这三行代码，结合刚刚的双向链表 h，我画出图，你就懂了。

![图片](assets/640-1705889984858-rs.png)

看，free_list 指向了缓冲头双向链表的第一个结构，然后就可以顺着这个结构，从双向链表中遍历到任何一个**缓冲头**结构了，而通过缓冲头又可以找到这个缓冲头对应的**缓冲块**。

简单说，**缓冲头就是具体缓冲块的管理结构，而 free_list 开头的双向链表又是缓冲头的管理结构**，整个管理体系就这样建立起来了。 

现在，从 `free_list`(一个指针) 开始遍历，就可以找到这里的所有内容了。







### 19.4 hash_table初始化

不过，还有最后一个事，能帮助更好管理，往下看。

```c
struct buffer_head * hash_table[NR_HASH];


void buffer_init(long buffer_end) {
    ...
    for (i=0;i<307;i++)
        hash_table[i]=NULL;
}
```

一个 307 大小的 **hash_table** 数组，这是干嘛的呢？

其实今天的这个代码在 **buffer.c** 中，而 buffer.c 是在 **fs** 包下的，也就是**文件系统**包下的。所以它今后是为文件系统而服务，具体是内核程序如果需要访问块设备中的数据，就都需要经过缓冲区来间接地操作。

也就是说，**读取块设备的数据（硬盘中的数据），需要先读到缓冲区中**，如果缓冲区已有了，就不用从块设备读取了，直接取走。

那**怎么知道缓冲区已经有了要读取的块设备中的数据**呢？从双向链表从头遍历当然可以，但是这效率可太低了。所以需要一个 **hashmap 的结构方便快速查找**，这就是 hash_table 这个数组的作用。

现在只是**初始化**这个 hash_table，还并没有哪个地方用到了它







### Notes-利用hash_table快速查询缓冲块

当要读取某个块设备上的数据时，首先要搜索相应的缓冲块，是下面这个函数。

```c
#define _hashfn(dev,block) (((unsigned)(dev^block))%307)
#define hash(dev,block) hash_table[_hashfn(dev,block)]

// 搜索合适的缓冲块 
struct buffer_head * getblk(int dev,int block) {
    ...
    struct buffer_head bh = get_hash_table(dev,block)；
    ...
}

struct buffer_head * get_hash_table(int dev, int block) {
    ...    
    find_buffer(dev,block);
    ...
}

static struct buffer_head * find_buffer(int dev, int block) { 
    ...     
    hash(dev,block);
    ...
}
```

一路跟下来发现，就是通过 `dev^block % 307` 即 `(设备号^逻辑块号) Mod 307`找到在 hash_table 里的索引下标，接下来就和 Java 里的 HashMap 类似，如果哈希冲突就形成链表，画成图就是这样。

![图片](assets/640-1705892441075.png)

**哈希表 + 双向链表**，如果刷算法题多了，很容易想到这可以实现 **LRU 算法**，没错，之后的缓冲区使用和弃用，正是这个算法发挥了作用。

也就是之后在讲通过文件系统来读取硬盘文件时，都需要使用和弃用这个缓冲区里的内容，**缓冲区**即是**用户进程的内存**和**硬盘**之间的桥梁。









## 20.硬盘初始化 hd_init

### 20.1 整体代码

今天，我们看 main 函数中最后两个初始化函数！

```c
void main(void) {
    ...
    hd_init(); //本文重点
    floppy_init();
    ...
}
```

**hd_init** 是**硬盘初始化**，我们不得不看。但 **floppy_init** 是**软盘初始化**，现在软盘几乎都被淘汰了，计算机中也没有软盘驱动器了，所以这个我们完全可以不看。



我们直接看 `hd_init` 这个硬盘初始化干了什么？

`kernel\blk_drv\hd.c`

```c
//struct blk_dev_struct {
//    void (*request_fn)(void);
//    struct request * current_request;
//};
//extern struct blk_dev_struct blk_dev[NR_BLK_DEV];

void hd_init(void) {
    blk_dev[3].request_fn = do_hd_request;
    set_intr_gate(0x2E,&hd_interrupt);
    outb_p(inb_p(0x21)&0xfb,0x21);
    outb(inb_p(0xA1)&0xbf,0xA1); 
}
```

一共就四行代码。

没错，初始化嘛，往往都比较简单，尤其是对硬件设备的初始化，大体都是：

1. 往某些 IO 端口上读写一些数据，表示开启它；
2. 然后再向中断向量表中添加一个中断，使得 CPU 能够响应这个硬件设备的动作；
3. 最后再初始化一些数据结构来管理。不过像是内存管理可能结构复杂些，外设的管理，相对就简单很多了。









### 20.2 blk_dev初始化

看第一行代码：

```c
void hd_init(void) {
    blk_dev[3].request_fn = do_hd_request;
    ...
}
```

我们把 **blk_dev** 数组索引 3 位置处的块设备管理结构 **blk_dev_struct** 的 **request_fn** 赋值为了 **do_hd_request**，这是啥意思呢？

因为有很多块设备，所以 Linux 0.11 内核用了一个 **blk_dev[]** 来进行管理，每一个索引表示一个块设备。

`kernel\blk_drv\ll_rw_blk.c`

```c
struct blk_dev_struct blk_dev[NR_BLK_DEV] = {
    { NULL, NULL },     /* no_dev */
    { NULL, NULL },     /* dev mem */
    { NULL, NULL },     /* dev fd */
    { NULL, NULL },     /* dev hd */
    { NULL, NULL },     /* dev ttyx */
    { NULL, NULL },     /* dev tty */
    { NULL, NULL }      /* dev lp */
};
```

你看，索引为 3 这个位置，就表示给硬盘 **hd** 这个块设备留的位置。

那么**每个块设备执行读写请求都有自己的函数实现**，在上层看来都是一个统一函数 **request_fn** 即可，具体实现各有不同，对于硬盘来说，这个实现就是 **do_hd_request** 函数。







### 20.3 设置hd_interrupt

我们再看第二行。

```c
void hd_init(void) {
    ...
    set_intr_gate(0x2E,&hd_interrupt);
    ...
}
```

对于中断我们已经很熟悉了，这里就是又设置了一个新的中断

- 中断号是 **0x2E**
- 中断处理函数是 **hd_interrupt**

也就是说硬盘发生读写时，硬盘会发出中断信号给 CPU，之后 CPU 便会陷入中断处理程序，也就是执行 `hd_interrupt` 函数。

```c
_hd_interrupt:
    ...
    xchgl _do_hd,%edx
    ...
    
// 如果是读盘操作，这个 do_hd 是 read_intr
static void read_intr(void) {
    ...
    do_hd_request();
    ...
}
```







### 20.4 开启硬盘中断

好了，再往下看后两行。

```c
void hd_init(void) {
    ...
    outb_p(inb_p(0x21)&0xfb,0x21);
    outb(inb_p(0xA1)&0xbf,0xA1); 
}
```

就是往几个 IO 端口上读写，其作用是**允许硬盘控制器发送中断请求信号**，仅此而已。我们向来是不深入硬件细节，知道往这个端口里写上这些数据，导致硬盘开启了中断，即可。









### Notes-到目前设置的中断

我们再次梳理下目前开启的中断都有哪些。

| 中断号     | 中断处理函数             |
| ---------- | ------------------------ |
| `0 ~ 0x10` | `trap_init` 里设置的一堆 |
| `0x20`     | `timer_interrupt`        |
| `0x21`     | `keyboard_interrupt`     |
| `0x2E`     | `hd_interrupt`           |
| `0x80`     | `system_call`            |

- 其中 **0-0x10** 这 17 个中断是 `trap_init` 里初始化设置的，是一些基本的中断，比如除零异常等。
- 之后，在控制台初始化 `con_init` 里，我们又设置了 **0x21** 键盘中断，这样按下键盘就有反应了。
- 再之后，我们在进程调度初始化 `sched_init` 里又设置了 **0x20** 时钟中断，并且开启定时器。最后又偷偷设置了一个极为重要的 **0x80** 系统调用中断。
- 现在，我们在硬盘初始化 `hd_init` 里，又设置了硬盘中断，这样硬盘读写完成后将通过中断来通知 CPU。

![1705895399933](assets/1705895399933.png)



















